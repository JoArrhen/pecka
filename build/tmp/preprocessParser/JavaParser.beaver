%header {: // Generated from /Users/johanarrhen/Git/ProgramAnalysis/pecka/build/tmp/preprocessParser/JavaParser.all
package org.extendj.parser;

 import org.extendj.ast.*;
 import org.extendj.scanner.JavaScanner;
 import org.extendj.scanner.UnicodeEscapeReader; :};
%embed {: // Generated from /Users/johanarrhen/Git/ProgramAnalysis/pecka/build/tmp/preprocessParser/JavaParser.all
class Events extends Parser.Events {
    public void scannerError(Scanner.Exception e) {
      errors.add(new Problem(null, e.getMessage(), e.line, e.column,
          Problem.Severity.ERROR, Problem.Kind.LEXICAL));
    }
    public void syntaxError(Symbol token) {
      if (!canSkipToken(token)) {
        int line = token.getLine(token.getStart());
        int column = token.getColumn(token.getStart());
        int endLine = token.getLine(token.getEnd());
        int endColumn = token.getColumn(token.getEnd());
        String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
        errors.add(new Problem(null, "unexpected token \"" + value + "\"",
            line, column, endLine, endColumn, Problem.Severity.ERROR, Problem.Kind.SYNTACTIC));
      }
    }
    public void unexpectedTokenRemoved(Symbol token) {
    }
    public void missingTokenInserted(Symbol token) {
    }
    public void misspelledTokenReplaced(Symbol token) {
    }
    public void errorPhraseRemoved(Symbol error) {
    }
  }

  {
    report = new Events(); // Use error handler in parser
  }

  public CompilationUnit parse(java.io.InputStream is, String fileName)
      throws java.io.IOException, beaver.Parser.Exception {
    CompilationUnit cu;
    errors = new ArrayList();
    try {
      JavaScanner scanner = new JavaScanner(new UnicodeEscapeReader(is));
      cu = (CompilationUnit) parse(scanner);
    } catch(Parser.Exception e) {
      // build empty compilation unit for failed error recovery
      cu = new CompilationUnit();
    } catch(Error e) {
      cu = new CompilationUnit();
      errors.add(new Problem(null, e.getMessage(), 0, 0,
          Problem.Severity.ERROR, Problem.Kind.LEXICAL));
    }
    for (java.util.Iterator iter = errors.iterator(); iter.hasNext(); ) {
      Problem p = (Problem) iter.next();
      p.setFileName(fileName);
      cu.addParseError(p);
    }
    return cu;
  }

  @Override
  protected void recoverFromError(Symbol token, TokenStream in)
      throws java.io.IOException, Parser.Exception {
    if (!canSkipToken(token)) {
      super.recoverFromError(token, in);
    }
  }

  protected static boolean canSkipToken(Symbol token) {
    return token.getId() == Terminals.DOCUMENTATION_COMMENT;
  }

  protected java.util.Collection errors = new ArrayList(); :};
%left LBRACK, RBRACK, DOT, LPAREN, RPAREN, POSTINCDEC;
%right PLUSPLUS, MINUSMINUS, NOT, COMP, UNARY;
%right NEW, CAST;
%left MULT, DIV, MOD;
%left PLUS, MINUS;
%left LSHIFT, RSHIFT, URSHIFT;
%left INSTANCEOF;
%left LT, GT, LTEQ, GTEQ;
%left EQEQ, NOTEQ;
%left AND;
%left XOR;
%left OR;
%left ANDAND;
%left OROR;
%right QUESTION, COLON;
%right EQ, PLUSEQ, MINUSEQ, MULTEQ, DIVEQ, MODEQ, ANDEQ, XOREQ, OREQ, LSHIFTEQ, RSHIFTEQ, URSHIFTEQ;
%left DOUBLECOLON, RARROW;
%nonassoc BOTTOM;
%terminals BOOLEAN;
%terminals BYTE;
%terminals SHORT;
%terminals INT;
%terminals LONG;
%terminals CHAR;
%terminals FLOAT;
%terminals DOUBLE;
%terminals IDENTIFIER;
%terminals DOT;
%terminals SEMICOLON;
%terminals DOCUMENTATION_COMMENT;
%terminals PACKAGE;
%terminals IMPORT;
%terminals MULT;
%terminals PUBLIC;
%terminals PROTECTED;
%terminals PRIVATE;
%terminals STATIC;
%terminals ABSTRACT;
%terminals FINAL;
%terminals NATIVE;
%terminals SYNCHRONIZED;
%terminals TRANSIENT;
%terminals VOLATILE;
%terminals STRICTFP;
%terminals CLASS;
%terminals EXTENDS;
%terminals IMPLEMENTS;
%terminals COMMA;
%terminals LBRACE;
%terminals RBRACE;
%terminals EQ;
%terminals LPAREN;
%terminals RPAREN;
%terminals VOID;
%terminals THROWS;
%terminals THIS;
%terminals SUPER;
%terminals INTERFACE;
%terminals IF;
%terminals ELSE;
%terminals COLON;
%terminals SWITCH;
%terminals CASE;
%terminals DEFAULT;
%terminals WHILE;
%terminals DO;
%terminals FOR;
%terminals BREAK;
%terminals CONTINUE;
%terminals RETURN;
%terminals THROW;
%terminals TRY;
%terminals CATCH;
%terminals FINALLY;
%terminals ASSERT;
%terminals NEW;
%terminals LBRACK;
%terminals RBRACK;
%terminals PLUSPLUS;
%terminals MINUSMINUS;
%terminals PLUS;
%terminals MINUS;
%terminals COMP;
%terminals NOT;
%terminals DIV;
%terminals MOD;
%terminals LSHIFT;
%terminals RSHIFT;
%terminals URSHIFT;
%terminals AND;
%terminals XOR;
%terminals OR;
%terminals ANDAND;
%terminals OROR;
%terminals QUESTION;
%terminals MULTEQ;
%terminals DIVEQ;
%terminals MODEQ;
%terminals PLUSEQ;
%terminals MINUSEQ;
%terminals LSHIFTEQ;
%terminals RSHIFTEQ;
%terminals URSHIFTEQ;
%terminals ANDEQ;
%terminals XOREQ;
%terminals OREQ;
%terminals AT;
%terminals LT;
%terminals GT;
%terminals LTEQ;
%terminals GTEQ;
%terminals INSTANCEOF;
%terminals EQEQ;
%terminals NOTEQ;
%terminals ELLIPSIS;
%terminals ENUM;
%terminals NUMERIC_LITERAL;
%terminals BOOLEAN_LITERAL;
%terminals CHARACTER_LITERAL;
%terminals STRING_LITERAL;
%terminals NULL_LITERAL;
%terminals DOUBLECOLON;
%terminals LTTYPE;
%terminals INTERCAST;
%terminals RARROW;
%terminals INFERRED_LAMBDA;
%typeof formal_parameter = "ParameterDeclaration";
%typeof continue_statement = "ContinueStmt";
%typeof single_type_import_declaration = "ImportDecl";
%typeof inferred_list = "List";
%typeof synchronized_statement = "SynchronizedStmt";
%typeof additional_bound_1 = "Access";
%typeof interface_type_list = "List";
%typeof array_creation_uninit = "Expr";
%typeof nongeneric_formal_parameter = "ParameterDeclaration";
%typeof interface_method_header = "MethodDecl";
%typeof interface_declaration = "InterfaceDecl";
%typeof return_statement = "ReturnStmt";
%typeof variable_initializers = "List";
%typeof type_argument = "Access";
%typeof type_argument_list = "List";
%typeof statement_expression = "ExprStmt";
%typeof element_value_pair = "ElementValuePair";
%typeof formal_parameter_list = "List";
%typeof formal_parameter_list_opt = "List";
%typeof conditional_or_expression_nn = "Expr";
%typeof type_argument_3 = "Access";
%typeof type_argument_1 = "Access";
%typeof switch_label = "Case";
%typeof type_argument_2 = "Access";
%typeof enum_body = "List";
%typeof field_declarators = "List";
%typeof switch_statement = "SwitchStmt";
%typeof class_instance_creation_expression = "Expr";
%typeof switch_block = "Block";
%typeof import_with_comment = "ImportDecl";
%typeof inclusive_or_expression = "Expr";
%typeof literal = "Expr";
%typeof conditional_expression = "Expr";
%typeof name_decl = "IdUse";
%typeof for_update = "List";
%typeof for_update_opt = "List";
%typeof shift_expression = "Expr";
%typeof block_statements = "List";
%typeof block_statements_opt = "List";
%typeof statement_expression_list = "List";
%typeof postincrement_expression = "Expr";
%typeof try_statement = "TryStmt";
%typeof annotation = "Annotation";
%typeof expression = "Expr";
%typeof expression_opt = "Opt";
%typeof additional_bound_list_1 = "List";
%typeof additional_bound = "Access";
%typeof assert_statement = "AssertStmt";
%typeof resource_list = "List";
%typeof for_statement = "ForStmt";
%typeof multiplicative_expression_nn = "Expr";
%typeof constructor_declaration = "ConstructorDecl";
%typeof extends_interfaces = "List";
%typeof conditional_or_expression = "Expr";
%typeof throw_statement = "ThrowStmt";
%typeof enum_constant = "BodyDecl";
%typeof type_declaration = "TypeDecl";
%typeof doc_comment = "String";
%typeof dim_expr = "Dims";
%typeof lambda_expression = "Expr";
%typeof nongeneric_array_type = "Access";
%typeof package_declaration = "IdUse";
%typeof element_value_array_initializer = "ElementArrayValue";
%typeof enhanced_for_statement_no_short_if = "Stmt";
%typeof field_declarator = "FieldDeclarator";
%typeof array_creation_init = "Expr";
%typeof interface_member_declarations = "List";
%typeof element_value = "ElementValue";
%typeof wildcard_3 = "Access";
%typeof wildcard_2 = "Access";
%typeof class_member_declaration = "BodyDecl";
%typeof inclusive_or_expression_nn = "Expr";
%typeof wildcard_1 = "Access";
%typeof and_expression = "Expr";
%typeof interface_member_declaration = "BodyDecl";
%typeof primitive_type = "Access";
%typeof type_bound = "List";
%typeof integral_type = "Access";
%typeof additive_expression = "Expr";
%typeof class_body_declarations = "List";
%typeof interface_type = "Access";
%typeof block_statement = "Stmt";
%typeof multiplicative_expression = "Expr";
%typeof normal_annotation = "Annotation";
%typeof type_import_on_demand_declaration = "ImportDecl";
%typeof class_body = "List";
%typeof formal_parameter_list_no_vararg_mixed_array = "List";
%typeof dim_exprs = "List";
%typeof annotation_type_element_declaration = "BodyDecl";
%typeof finally = "Block";
%typeof annotation_type_body = "List";
%typeof exclusive_or_expression_nn = "Expr";
%typeof import_declarations = "List";
%typeof marker_annotation = "Annotation";
%typeof relational_expression_nn = "Expr";
%typeof instance_initializer = "InstanceInitializer";
%typeof class_type_list = "List";
%typeof method_reference = "Expr";
%typeof field_access = "Access";
%typeof enhanced_for_statement = "Stmt";
%typeof name = "Access";
%typeof variable_declarator = "VariableDeclarator";
%typeof dims = "List";
%typeof dims_opt = "List";
%typeof array_access = "Access";
%typeof conditional_expression_nn = "Expr";
%typeof modifiers = "List";
%typeof conditional_and_expression = "Expr";
%typeof shift_expression_nn = "Expr";
%typeof preincrement_expression = "Expr";
%typeof unary_expression_not_plus_minus = "Expr";
%typeof constant_expression = "Expr";
%typeof statement = "Stmt";
%typeof array_type = "Access";
%typeof type_arguments = "List";
%typeof type_arguments_opt = "List";
%typeof try_with_resource = "TryWithResources";
%typeof interfaces = "List";
%typeof qualified_name_decl = "IdUse";
%typeof primary_no_new_array = "Expr";
%typeof assignment_expression = "Expr";
%typeof comma_formal_parameter_list = "List";
%typeof method_body = "Opt";
%typeof interface_body = "List";
%typeof type_parameter = "TypeVariable";
%typeof body_decl_with_comment = "BodyDecl";
%typeof type_declarations = "List";
%typeof constant_declaration = "BodyDecl";
%typeof local_variable_declaration = "VarDeclStmt";
%typeof subclass_body = "Opt";
%typeof subclass_body_opt = "Opt";
%typeof postfix_expression = "Expr";
%typeof type = "Access";
%typeof explicit_constructor_invocation = "ExprStmt";
%typeof expression_nn = "Expr";
%typeof for_statement_no_short_if = "ForStmt";
%typeof class_type = "Access";
%typeof single_element_annotation = "Annotation";
%typeof multi_catch_param = "CatchParameterDeclaration";
%typeof numeric_type = "Access";
%typeof block = "Block";
%typeof while_statement = "WhileStmt";
%typeof unary_expression_nn = "Expr";
%typeof if_then_else_statement = "IfStmt";
%typeof empty_statement = "EmptyStmt";
%typeof package_with_comment = "IdUse";
%typeof constructor_reference = "Expr";
%typeof goal = "CompilationUnit";
%typeof additional_bound_list = "List";
%typeof enhanced_for_parameter = "VariableDeclarator";
%typeof unary_expression_not_plus_minus_nn = "Expr";
%typeof exclusive_or_expression = "Expr";
%typeof method_header = "MethodDecl";
%typeof element_values = "List";
%typeof do_statement = "DoStmt";
%typeof primary = "Expr";
%typeof for_init = "List";
%typeof for_init_opt = "List";
%typeof class_or_interface_type = "Access";
%typeof instanceof_expression = "Expr";
%typeof variable_declarators = "List";
%typeof compilation_unit = "CompilationUnit";
%typeof postfix_expression_nn = "Expr";
%typeof postdecrement_expression = "Expr";
%typeof variable_initializer = "Expr";
%typeof multi_catch_type = "List";
%typeof if_then_else_statement_no_short_if = "IfStmt";
%typeof catch_clause = "CatchClause";
%typeof field_declaration = "BodyDecl";
%typeof expression_statement = "ExprStmt";
%typeof doc_comments = "String";
%typeof default_value = "ElementValue";
%typeof default_value_opt = "Opt";
%typeof if_then_statement = "IfStmt";
%typeof reference_type = "Access";
%typeof doc_comments_opt = "String";
%typeof qualified_name = "Access";
%typeof class_or_interface = "Access";
%typeof argument_list = "List";
%typeof argument_list_opt = "List";
%typeof relational_expression = "Expr";
%typeof break_statement = "BreakStmt";
%typeof type_with_comment = "TypeDecl";
%typeof class_body_declaration = "BodyDecl";
%typeof cast_expression = "Expr";
%typeof assignment_expression_nn = "Expr";
%typeof type_parameter_1 = "TypeVariable";
%typeof array_initializer = "ArrayInit";
%typeof annotation_type_declaration = "AnnotationDecl";
%typeof modifier = "Modifier";
%typeof and_expression_nn = "Expr";
%typeof catches = "List";
%typeof annotations = "List";
%typeof unary_expression = "Expr";
%typeof enum_body_declarations = "List";
%typeof nongeneric_class_or_interface_type = "Access";
%typeof simple_name = "Access";
%typeof element_value_pairs = "List";
%typeof element_value_pairs_opt = "List";
%typeof while_statement_no_short_if = "WhileStmt";
%typeof interface_member_with_comment = "BodyDecl";
%typeof class_literal = "ClassAccess";
%typeof lambda_body = "LambdaBody";
%typeof resource_declaration = "Resource";
%typeof import_declaration = "ImportDecl";
%typeof additive_expression_nn = "Expr";
%typeof type_argument_list_1 = "List";
%typeof resource = "Resource";
%typeof method_declaration = "MethodDecl";
%typeof type_argument_list_2 = "List";
%typeof type_argument_list_3 = "List";
%typeof simple_name_decl = "IdUse";
%typeof equality_expression_nn = "Expr";
%typeof formal_parameter_no_vararg_mixed_array = "ParameterDeclaration";
%typeof throws = "List";
%typeof throws_opt = "List";
%typeof switch_statements = "List";
%typeof method_invocation = "Access";
%typeof statement_no_short_if = "Stmt";
%typeof floating_point_type = "Access";
%typeof labeled_statement_no_short_if = "LabeledStmt";
%typeof equality_expression = "Expr";
%typeof enum_declaration = "EnumDecl";
%typeof nongeneric_reference_type = "Access";
%typeof annotation_type_element_declarations = "List";
%typeof annotation_type_element_declarations_opt = "List";
%typeof field_declarator_id = "FieldDeclarator";
%typeof interface_method_declaration = "MethodDecl";
%typeof variable_declarator_id = "VariableDeclarator";
%typeof wildcard = "Access";
%typeof predecrement_expression = "Expr";
%typeof type_parameters = "List";
%typeof type_bound_1 = "List";
%typeof statement_without_trailing_substatement = "Stmt";
%typeof static_import_on_demand_declaration = "ImportDecl";
%typeof abstract_method_declaration = "BodyDecl";
%typeof labeled_statement = "LabeledStmt";
%typeof static_initializer = "StaticInitializer";
%typeof type_parameter_list = "List";
%typeof enum_constants = "List";
%typeof reference_type_3 = "Access";
%typeof assignment = "Expr";
%typeof conditional_and_expression_nn = "Expr";
%typeof reference_type_2 = "Access";
%typeof reference_type_1 = "Access";
%typeof resources = "List";
%typeof class_declaration = "ClassDecl";
%typeof super = "Opt";
%typeof local_variable_declaration_statement = "VarDeclStmt";
%typeof single_static_import_declaration = "ImportDecl";
%typeof nongeneric_type = "Access";
%typeof type_parameter_list_1 = "List";
%typeof arguments = "List";
%typeof instanceof_expression_nn = "Expr";
%goal goal;
goal =
    compilation_unit.compilation_unit   ;
type =
    primitive_type.primitive_type 
  | reference_type.reference_type   ;
primitive_type =
    numeric_type.numeric_type 
  | BOOLEAN.BOOLEAN {: return new PrimitiveTypeAccess("boolean"); :}
  ;
numeric_type =
    integral_type.integral_type 
  | floating_point_type.floating_point_type   ;
integral_type =
    BYTE.BYTE {: return new PrimitiveTypeAccess("byte"); :}

  | SHORT.SHORT {: return new PrimitiveTypeAccess("short"); :}

  | INT.INT {: return new PrimitiveTypeAccess("int"); :}

  | LONG.LONG {: return new PrimitiveTypeAccess("long"); :}

  | CHAR.CHAR {: return new PrimitiveTypeAccess("char"); :}
  ;
floating_point_type =
    FLOAT.FLOAT {: return new PrimitiveTypeAccess("float"); :}

  | DOUBLE.DOUBLE {: return new PrimitiveTypeAccess("double"); :}
  ;
reference_type =
    class_or_interface_type.class_or_interface_type 
  | array_type.array_type   ;
class_type =
    class_or_interface_type.class_or_interface_type   ;
interface_type =
    class_or_interface_type.class_or_interface_type   ;
array_type =
    primitive_type.t dims.dims @ BOTTOM {: return t.addArrayDims(dims); :}

  | name.name dims.dims @ BOTTOM {: return name.addArrayDims(dims); :}
  ;
name =
    simple_name.simple_name 
  | qualified_name.qualified_name   ;
simple_name =
    IDENTIFIER.IDENTIFIER {: return new ParseName(IDENTIFIER); :}
  ;
qualified_name =
    name.n DOT.DOT simple_name.i {: return n.qualifiesAccess(i); :}
  ;
compilation_unit =
    package_with_comment.p doc_comments_opt.doc_comments_opt {: return new CompilationUnit(p.getID(), new List(), new List()); :}

  | package_with_comment.p import_declarations.i doc_comments_opt.doc_comments_opt {: return new CompilationUnit(p.getID(), i, new List()); :}

  | package_with_comment.p type_declarations.t doc_comments_opt.doc_comments_opt {: return new CompilationUnit(p.getID(), new List(), t); :}

  | package_with_comment.p import_declarations.i type_declarations.t doc_comments_opt.doc_comments_opt {: return new CompilationUnit(p.getID(), i, t); :}

  | doc_comments_opt.doc_comments_opt {: return new CompilationUnit("", new List(), new List()); :}

  | import_declarations.i doc_comments_opt.doc_comments_opt {: return new CompilationUnit("", i, new List()); :}

  | type_declarations.t doc_comments_opt.doc_comments_opt {: return new CompilationUnit("", new List(), t); :}

  | import_declarations.i type_declarations.t doc_comments_opt.doc_comments_opt {: return new CompilationUnit("", i, t); :}
  ;
import_declarations =
    import_with_comment.i {: return new List().add(i); :}

  | import_declarations.l import_with_comment.i {: return l.add(i); :}
  ;
type_declarations =
    SEMICOLON.SEMICOLON {: return new List(); :}

  | type_with_comment.t {: return new List().add(t); :}

  | type_declarations.l SEMICOLON.SEMICOLON {: return l; :}

  | type_declarations.l type_with_comment.t {: return l.add(t); :}
  ;
doc_comments_opt =
    
  | doc_comments.doc_comments   ;
doc_comment =
    DOCUMENTATION_COMMENT.dc {: return new Symbol(Terminals.DOCUMENTATION_COMMENT, ((String)dc.value)); :}
  ;
doc_comments =
    doc_comment.d 
  | doc_comments.doc_comments doc_comment.dc {: return new Symbol(Terminals.DOCUMENTATION_COMMENT, dc); :}
  ;
package_with_comment =
    package_declaration.package_declaration 
  | doc_comments.doc_comments package_declaration.package_declaration   ;
package_declaration =
    PACKAGE.PACKAGE name_decl.name_decl SEMICOLON.SEMICOLON {: return name_decl; :}
  ;
name_decl =
    simple_name_decl.simple_name_decl 
  | qualified_name_decl.qualified_name_decl   ;
simple_name_decl =
    IDENTIFIER.IDENTIFIER {: return new IdUse(IDENTIFIER); :}
  ;
qualified_name_decl =
    name_decl.n DOT.DOT IDENTIFIER.i {: return new IdUse(n.getID() + "." + ((String)i.value)); :}
  ;
import_with_comment =
    doc_comments_opt.doc_comments_opt import_declaration.import_declaration   ;
import_declaration =
    single_type_import_declaration.single_type_import_declaration 
  | type_import_on_demand_declaration.type_import_on_demand_declaration   ;
single_type_import_declaration =
    IMPORT.IMPORT name.name SEMICOLON.SEMICOLON {: return new SingleTypeImportDecl(name); :}
  ;
type_import_on_demand_declaration =
    IMPORT.IMPORT name.name DOT.DOT MULT.MULT SEMICOLON.SEMICOLON {: return new TypeImportOnDemandDecl(name); :}
  ;
type_with_comment =
    type_declaration.type_declaration 
  | doc_comments.dc type_declaration.d {: d.docComment = dc;
      return d; :}
  ;
type_declaration =
    class_declaration.class_declaration 
  | interface_declaration.interface_declaration   ;
modifiers =
    modifier.m {: return new List().add(m); :}

  | modifiers.l modifier.m {: return l.add(m); :}
  ;
modifier =
    PUBLIC.PUBLIC {: return new Modifier("public"); :}

  | PROTECTED.PROTECTED {: return new Modifier("protected"); :}

  | PRIVATE.PRIVATE {: return new Modifier("private"); :}

  | STATIC.STATIC {: return new Modifier("static"); :}

  | ABSTRACT.ABSTRACT {: return new Modifier("abstract"); :}

  | FINAL.FINAL {: return new Modifier("final"); :}

  | NATIVE.NATIVE {: return new Modifier("native"); :}

  | SYNCHRONIZED.SYNCHRONIZED {: return new Modifier("synchronized"); :}

  | TRANSIENT.TRANSIENT {: return new Modifier("transient"); :}

  | VOLATILE.VOLATILE {: return new Modifier("volatile"); :}

  | STRICTFP.STRICTFP {: return new Modifier("strictfp"); :}
  ;
class_declaration =
    CLASS.CLASS IDENTIFIER.IDENTIFIER class_body.b {: return new ClassDecl(new Modifiers(new List()), IDENTIFIER, new Opt(), new List(), b); :}

  | modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER class_body.b {: return new ClassDecl(new Modifiers(m), IDENTIFIER, new Opt(), new List(), b); :}

  | CLASS.CLASS IDENTIFIER.IDENTIFIER super.s class_body.b {: return new ClassDecl(new Modifiers(new List()), IDENTIFIER, s, new List(), b); :}

  | modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER super.s class_body.b {: return new ClassDecl(new Modifiers(m), IDENTIFIER, s, new List(), b); :}

  | CLASS.CLASS IDENTIFIER.IDENTIFIER interfaces.i class_body.b {: return new ClassDecl(new Modifiers(new List()), IDENTIFIER, new Opt(), i, b); :}

  | modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER interfaces.i class_body.b {: return new ClassDecl(new Modifiers(m), IDENTIFIER, new Opt(), i, b); :}

  | CLASS.CLASS IDENTIFIER.IDENTIFIER super.s interfaces.i class_body.b {: return new ClassDecl(new Modifiers(new List()), IDENTIFIER, s, i, b); :}

  | modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER super.s interfaces.i class_body.b {: return new ClassDecl(new Modifiers(m), IDENTIFIER, s, i, b); :}
  ;
super =
    EXTENDS.EXTENDS class_type.class_type {: return new Opt(class_type); :}
  ;
interfaces =
    IMPLEMENTS.IMPLEMENTS interface_type_list.i {: return i; :}
  ;
interface_type_list =
    interface_type.i {: return new List().add(i); :}

  | interface_type_list.l COMMA.COMMA interface_type.i {: return l.add(i); :}
  ;
class_body =
    LBRACE.LBRACE doc_comments_opt.doc_comments_opt RBRACE.RBRACE {: return new List(); :}

  | LBRACE.LBRACE class_body_declarations.c doc_comments_opt.doc_comments_opt RBRACE.RBRACE {: return c; :}
  ;
class_body_declarations =
    body_decl_with_comment.c {: return new List().add(c); :}

  | class_body_declarations.l body_decl_with_comment.c {: return l.add(c); :}
  ;
body_decl_with_comment =
    class_body_declaration.class_body_declaration 
  | doc_comments.dc class_body_declaration.d {: d.docComment = dc;
      return d; :}
  ;
class_body_declaration =
    class_member_declaration.class_member_declaration 
  | instance_initializer.instance_initializer 
  | static_initializer.static_initializer 
  | constructor_declaration.constructor_declaration   ;
class_member_declaration =
    field_declaration.field_declaration 
  | method_declaration.method_declaration 
  | class_declaration.c {: return new MemberClassDecl(c); :}

  | interface_declaration.i {: return new MemberInterfaceDecl(i); :}

  | SEMICOLON.SEMICOLON {: return new InstanceInitializer(new Block()); :}
  ;
field_declaration =
    type.t field_declarators.v SEMICOLON.SEMICOLON {: return new FieldDecl(new Modifiers(new List()), t, v); :}

  | modifiers.m type.t field_declarators.v SEMICOLON.SEMICOLON {: return new FieldDecl(new Modifiers(m), t, v); :}
  ;
field_declarators =
    field_declarator.v {: return new List().add(v); :}

  | field_declarators.l COMMA.COMMA field_declarator.v {: return l.add(v); :}
  ;
field_declarator =
    field_declarator_id.field_declarator_id 
  | field_declarator_id.v EQ.EQ variable_initializer.i {: v.setInit(i); return v; :}
  ;
field_declarator_id =
    IDENTIFIER.IDENTIFIER dims_opt.d {: return new FieldDeclarator(IDENTIFIER, d, new Opt()); :}
  ;
variable_initializer =
    expression.expression 
  | array_initializer.array_initializer   ;
method_declaration =
    method_header.m method_body.b {: m.setBlockOpt(b); return m; :}
  ;
method_header =
    type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN {: return new MethodDecl(new Modifiers(new List()), t.addArrayDims(new List()), IDENTIFIER, l, new List(), new Opt()); :}

  | modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN {: return new MethodDecl(new Modifiers(m), t.addArrayDims(new List()), IDENTIFIER, l, new List(), new Opt()); :}

  | type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d {: return new MethodDecl(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER, l, new List(), new Opt()); :}

  | modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d {: return new MethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, l, new List(), new Opt()); :}

  | type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws.tl {: return new MethodDecl(new Modifiers(new List()), t.addArrayDims(new List()), IDENTIFIER, l, tl, new Opt()); :}

  | modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws.tl {: return new MethodDecl(new Modifiers(m), t.addArrayDims(new List()), IDENTIFIER, l, tl, new Opt()); :}

  | type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d throws.tl {: return new MethodDecl(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER, l, tl, new Opt()); :}

  | modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d throws.tl {: return new MethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, l, tl, new Opt()); :}

  | VOID.VOID IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws_opt.tl {: return new MethodDecl(new Modifiers(new List()), new PrimitiveTypeAccess("void"), IDENTIFIER, l, tl, new Opt()); :}

  | modifiers.m VOID.VOID IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws_opt.tl {: return new MethodDecl(new Modifiers(m), new PrimitiveTypeAccess("void"), IDENTIFIER, l, tl, new Opt()); :}
  ;
formal_parameter_list =
    formal_parameter.f {: return new List().add(f); :}

  | formal_parameter_list.l COMMA.COMMA formal_parameter.f {: return l.add(f); :}
  ;
formal_parameter =
    type.t IDENTIFIER.IDENTIFIER dims_opt.d {: return new ParameterDeclaration(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER); :}

  | modifiers.m type.t IDENTIFIER.IDENTIFIER dims_opt.d {: return new ParameterDeclaration(new Modifiers(m), t.addArrayDims(d), IDENTIFIER); :}
  ;
throws =
    THROWS.THROWS class_type_list.l {: return l; :}
  ;
class_type_list =
    class_type.c {: return new List().add(c); :}

  | class_type_list.l COMMA.COMMA class_type.c {: return l.add(c); :}
  ;
method_body =
    block.block {: return new Opt(block); :}

  | SEMICOLON.SEMICOLON {: return new Opt(); :}
  ;
static_initializer =
    STATIC.STATIC block.block {: return new StaticInitializer(block); :}
  ;
instance_initializer =
    block.block {: return new InstanceInitializer(block); :}
  ;
constructor_declaration =
    IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE RBRACE.RBRACE {: Block b = new Block(new List()); new List().setStart(LBRACE.getStart() + 1); b.setStart(LBRACE.getStart()); b.setEnd(RBRACE.getEnd());
       return new ConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(), b); :}

  | modifiers.m IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE RBRACE.RBRACE {: Block b = new Block(new List()); new List().setStart(LBRACE.getStart() + 1); b.setStart(LBRACE.getStart()); b.setEnd(RBRACE.getEnd());
       return new ConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(), b); :}

  | IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c RBRACE.RBRACE {: Block b = new Block(new List()); new List().setStart(LBRACE.getStart() + 1); b.setStart(LBRACE.getStart()); b.setEnd(RBRACE.getEnd());
       return new ConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(c), b); :}

  | modifiers.m IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c RBRACE.RBRACE {: Block b = new Block(new List()); new List().setStart(LBRACE.getStart() + 1); b.setStart(LBRACE.getStart()); b.setEnd(RBRACE.getEnd());
       return new ConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(c), b); :}

  | IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE block_statements.l RBRACE.RBRACE {: Block b = new Block(l); l.setStart(LBRACE.getStart() + 1); b.setStart(LBRACE.getStart()); b.setEnd(RBRACE.getEnd());
       return new ConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(), b); :}

  | modifiers.m IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE block_statements.l RBRACE.RBRACE {: Block b = new Block(l); l.setStart(LBRACE.getStart() + 1); b.setStart(LBRACE.getStart()); b.setEnd(RBRACE.getEnd());
       return new ConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(), b); :}

  | IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c block_statements.l RBRACE.RBRACE {: Block b = new Block(l); l.setStart(LBRACE.getStart() + 1); b.setStart(LBRACE.getStart()); b.setEnd(RBRACE.getEnd());
       return new ConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(c), b); :}

  | modifiers.m IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c block_statements.l RBRACE.RBRACE {: Block b = new Block(l); l.setStart(LBRACE.getStart() + 1); b.setStart(LBRACE.getStart()); b.setEnd(RBRACE.getEnd());
       return new ConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(c), b); :}
  ;
explicit_constructor_invocation =
    THIS.THIS LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON {: ConstructorAccess c = new ConstructorAccess("this", l);
       c.setStart(THIS.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(c); :}

  | SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON {: SuperConstructorAccess c = new SuperConstructorAccess("super", l);
       c.setStart(SUPER.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(c); :}

  | primary.p DOT.DOT SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON {: SuperConstructorAccess c = new SuperConstructorAccess("super", l);
       c.setStart(SUPER.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(p.qualifiesAccess(c)); :}

  | name.n DOT.DOT SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON {: SuperConstructorAccess c = new SuperConstructorAccess("super", l);
       c.setStart(SUPER.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(n.qualifiesAccess(c)); :}
  ;
interface_declaration =
    INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER interface_body.b {: return new InterfaceDecl(new Modifiers(new List()), IDENTIFIER, new List(), b); :}

  | modifiers.m INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER interface_body.b {: return new InterfaceDecl(new Modifiers(m), IDENTIFIER, new List(), b); :}

  | INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER extends_interfaces.i interface_body.b {: return new InterfaceDecl(new Modifiers(new List()), IDENTIFIER, i, b); :}

  | modifiers.m INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER extends_interfaces.i interface_body.b {: return new InterfaceDecl(new Modifiers(m), IDENTIFIER, i, b); :}
  ;
extends_interfaces =
    EXTENDS.EXTENDS interface_type.i {: return new List().add(i); :}

  | extends_interfaces.l COMMA.COMMA interface_type.i {: return l.add(i); :}
  ;
interface_body =
    LBRACE.LBRACE doc_comments_opt.doc_comments_opt RBRACE.RBRACE {: return new List(); :}

  | LBRACE.LBRACE interface_member_declarations.i doc_comments_opt.doc_comments_opt RBRACE.RBRACE {: return i; :}
  ;
interface_member_declarations =
    interface_member_with_comment.i {: return new List().add(i); :}

  | interface_member_declarations.l interface_member_with_comment.i {: return l.add(i); :}
  ;
interface_member_with_comment =
    interface_member_declaration.interface_member_declaration 
  | doc_comments.dc interface_member_declaration.d {: d.docComment = dc;
      return d; :}
  ;
interface_member_declaration =
    constant_declaration.constant_declaration 
  | abstract_method_declaration.abstract_method_declaration 
  | class_declaration.c {: return new MemberClassDecl(c); :}

  | interface_declaration.i {: return new MemberInterfaceDecl(i); :}

  | SEMICOLON.SEMICOLON {: return new StaticInitializer(new Block()); :}
  ;
constant_declaration =
    field_declaration.field_declaration   ;
array_initializer =
    LBRACE.LBRACE RBRACE.RBRACE {: return new ArrayInit(new List()); :}

  | LBRACE.LBRACE variable_initializers.v RBRACE.RBRACE {: return new ArrayInit(v); :}

  | LBRACE.LBRACE COMMA.COMMA RBRACE.RBRACE {: return new ArrayInit(new List()); :}

  | LBRACE.LBRACE variable_initializers.v COMMA.COMMA RBRACE.RBRACE {: return new ArrayInit(v); :}
  ;
variable_initializers =
    variable_initializer.v {: return new List().add(v); :}

  | variable_initializers.l COMMA.COMMA variable_initializer.v {: return l.add(v); :}
  ;
block =
    LBRACE.LBRACE block_statements_opt.l RBRACE.RBRACE {: return new Block(l); :}
  ;
block_statements =
    block_statement.b {: return new List().add(b); :}

  | block_statements.l block_statement.b {: return l.add(b); :}
  ;
block_statement =
    local_variable_declaration_statement.local_variable_declaration_statement 
  | class_declaration.c {: return new LocalClassDeclStmt(c); :}

  | statement.statement   ;
local_variable_declaration_statement =
    local_variable_declaration.l SEMICOLON.SEMICOLON {: return l; :}
  ;
local_variable_declaration =
    type.t variable_declarators.l {: return new VarDeclStmt(new Modifiers(new List()), t, l); :}

  | modifiers.m type.t variable_declarators.l {: return new VarDeclStmt(new Modifiers(m), t, l); :}
  ;
variable_declarators =
    variable_declarator.v {: return new List().add(v); :}

  | variable_declarators.l COMMA.COMMA variable_declarator.v {: return l.add(v); :}
  ;
variable_declarator =
    variable_declarator_id.variable_declarator_id 
  | variable_declarator_id.v EQ.EQ variable_initializer.i {: v.setInit(i); return v; :}
  ;
variable_declarator_id =
    IDENTIFIER.IDENTIFIER dims_opt.d {: return new VariableDeclarator(IDENTIFIER, d, new Opt()); :}
  ;
statement =
    statement_without_trailing_substatement.statement_without_trailing_substatement 
  | labeled_statement.labeled_statement 
  | if_then_statement.if_then_statement 
  | if_then_else_statement.if_then_else_statement 
  | while_statement.while_statement 
  | for_statement.for_statement   ;
statement_without_trailing_substatement =
    block.block 
  | empty_statement.empty_statement 
  | expression_statement.expression_statement 
  | switch_statement.switch_statement 
  | do_statement.do_statement 
  | break_statement.break_statement 
  | continue_statement.continue_statement 
  | return_statement.return_statement 
  | synchronized_statement.synchronized_statement 
  | throw_statement.throw_statement 
  | try_statement.try_statement 
  | assert_statement.assert_statement   ;
statement_no_short_if =
    statement_without_trailing_substatement.statement_without_trailing_substatement 
  | labeled_statement_no_short_if.labeled_statement_no_short_if 
  | if_then_else_statement_no_short_if.if_then_else_statement_no_short_if 
  | while_statement_no_short_if.while_statement_no_short_if 
  | for_statement_no_short_if.for_statement_no_short_if   ;
if_then_statement =
    IF.IF LPAREN.LPAREN expression.e RPAREN.RPAREN statement.s {: return new IfStmt(e, s, new Opt()); :}
  ;
if_then_else_statement =
    IF.IF LPAREN.LPAREN expression.e RPAREN.RPAREN statement_no_short_if.t ELSE.ELSE statement.els {: return new IfStmt(e, t, new Opt(els)); :}
  ;
if_then_else_statement_no_short_if =
    IF.IF LPAREN.LPAREN expression.e RPAREN.RPAREN statement_no_short_if.t ELSE.ELSE statement_no_short_if.els {: return new IfStmt(e, t, new Opt(els)); :}
  ;
empty_statement =
    SEMICOLON.SEMICOLON {: return new EmptyStmt(); :}
  ;
labeled_statement =
    IDENTIFIER.id COLON.COLON statement.s {: return new LabeledStmt(((String)id.value), s); :}
  ;
labeled_statement_no_short_if =
    IDENTIFIER.id COLON.COLON statement_no_short_if.s {: return new LabeledStmt(((String)id.value), s); :}
  ;
expression_statement =
    statement_expression.e SEMICOLON.SEMICOLON {: return e; :}
  ;
statement_expression =
    assignment.a {: return new ExprStmt(a); :}

  | preincrement_expression.e {: return new ExprStmt(e); :}

  | predecrement_expression.e {: return new ExprStmt(e); :}

  | postincrement_expression.e {: return new ExprStmt(e); :}

  | postdecrement_expression.e {: return new ExprStmt(e); :}

  | method_invocation.i {: return new ExprStmt(i); :}

  | class_instance_creation_expression.e {: return new ExprStmt(e); :}
  ;
switch_statement =
    SWITCH.SWITCH LPAREN.LPAREN expression.e RPAREN.RPAREN switch_block.l {: return new SwitchStmt(e, l); :}
  ;
switch_block =
    LBRACE.LBRACE switch_statements.l RBRACE.RBRACE {: return new Block(l); :}

  | LBRACE.LBRACE RBRACE.RBRACE {: return new Block(new List()); :}
  ;
switch_statements =
    switch_label.s {: return new List().add(s); :}

  | switch_statements.l switch_label.s {: return l.add(s); :}

  | switch_statements.l block_statement.b {: return l.add(b); :}
  ;
switch_label =
    CASE.CASE constant_expression.e COLON.COLON {: return new ConstCase(e); :}

  | DEFAULT.DEFAULT COLON.COLON {: return new DefaultCase(); :}
  ;
while_statement =
    WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN statement.s {: return new WhileStmt(e, s); :}
  ;
while_statement_no_short_if =
    WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN statement_no_short_if.s {: return new WhileStmt(e, s); :}
  ;
do_statement =
    DO.DO statement.s WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN SEMICOLON.SEMICOLON {: return new DoStmt(s, e); :}
  ;
for_statement =
    FOR.FOR LPAREN.LPAREN for_init_opt.i SEMICOLON.SEMICOLON expression_opt.e SEMICOLON.SEMICOLON_ for_update_opt.u RPAREN.RPAREN statement.s {: return new ForStmt(i, e, u, s); :}
  ;
for_statement_no_short_if =
    FOR.FOR LPAREN.LPAREN for_init_opt.i SEMICOLON.SEMICOLON expression_opt.e SEMICOLON.SEMICOLON_ for_update_opt.u RPAREN.RPAREN statement_no_short_if.s {: return new ForStmt(i, e, u, s); :}
  ;
for_init =
    statement_expression_list.statement_expression_list 
  | local_variable_declaration.d {: return new List().add(d); :}
  ;
for_update =
    statement_expression_list.statement_expression_list   ;
statement_expression_list =
    statement_expression.e {: return new List().add(e); :}

  | statement_expression_list.l COMMA.COMMA statement_expression.e {: return l.add(e); :}
  ;
break_statement =
    BREAK.BREAK IDENTIFIER.id SEMICOLON.SEMICOLON {: return new BreakStmt(((String)id.value)); :}

  | BREAK.BREAK SEMICOLON.SEMICOLON {: return new BreakStmt(""); :}
  ;
continue_statement =
    CONTINUE.CONTINUE IDENTIFIER.id SEMICOLON.SEMICOLON {: return new ContinueStmt(((String)id.value)); :}

  | CONTINUE.CONTINUE SEMICOLON.SEMICOLON {: return new ContinueStmt(""); :}
  ;
return_statement =
    RETURN.RETURN expression_opt.expression SEMICOLON.SEMICOLON {: return new ReturnStmt(expression); :}
  ;
throw_statement =
    THROW.THROW expression.expression SEMICOLON.SEMICOLON {: return new ThrowStmt(expression); :}
  ;
synchronized_statement =
    SYNCHRONIZED.SYNCHRONIZED LPAREN.LPAREN expression.e RPAREN.RPAREN block.b {: return new SynchronizedStmt(e, b); :}
  ;
try_statement =
    TRY.TRY block.b catches.c {: return new TryStmt(b, c, new Opt()); :}

  | TRY.TRY block.b finally.f {: return new TryStmt(b, new List(), new Opt(f)); :}

  | TRY.TRY block.b catches.c finally.f {: return new TryStmt(b, c, new Opt(f)); :}
  ;
catches =
    catch_clause.c {: return new List().add(c); :}

  | catches.l catch_clause.c {: return l.add(c); :}
  ;
catch_clause =
    CATCH.CATCH LPAREN.LPAREN formal_parameter.p RPAREN.RPAREN block.b {: return new BasicCatch(p, b); :}
  ;
finally =
    FINALLY.FINALLY block.b {: return b; :}
  ;
assert_statement =
    ASSERT.ASSERT expression.e SEMICOLON.SEMICOLON {: return new AssertStmt(e, new Opt()); :}

  | ASSERT.ASSERT expression.e COLON.COLON expression.s SEMICOLON.SEMICOLON {: return new AssertStmt(e, new Opt(s)); :}
  ;
primary =
    primary_no_new_array.primary_no_new_array @ BOTTOM 
  | array_creation_init.array_creation_init 
  | array_creation_uninit.array_creation_uninit   ;
class_literal =
    CLASS.CLASS {: return new ClassAccess(); :}
  ;
subclass_body =
    class_body.b {: // The name of the anonymous class does not matter here, except that it should not collide
      // with non-anonymous classes. We give it the name "#Anonymous" because no user-defined
      // class can have that name.
      return new Opt(new AnonymousDecl(new Modifiers(), "#Anonymous", b)); :}
  ;
argument_list =
    expression.e {: return new List().add(e); :}

  | argument_list.l COMMA.COMMA expression.e {: return l.add(e); :}
  ;
array_creation_uninit =
    NEW.NEW primitive_type.t dim_exprs.d {: return new ArrayCreationExpr(t.addArrayDims(d), new Opt()); :}

  | NEW.NEW primitive_type.t dim_exprs.d dims.e {: return new ArrayCreationExpr(t.addArrayDims(d).addArrayDims(e), new Opt()); :}

  | NEW.NEW class_or_interface_type.t dim_exprs.d {: return new ArrayCreationExpr(t.addArrayDims(d), new Opt()); :}

  | NEW.NEW class_or_interface_type.t dim_exprs.d dims.e {: return new ArrayCreationExpr(t.addArrayDims(d).addArrayDims(e), new Opt()); :}
  ;
array_creation_init =
    NEW.NEW primitive_type.t dims.d array_initializer.i {: return new ArrayCreationExpr(t.addArrayDims(d), new Opt(i)); :}

  | NEW.NEW class_or_interface_type.t dims.d array_initializer.i {: return new ArrayCreationExpr(t.addArrayDims(d), new Opt(i)); :}
  ;
dim_exprs =
    dim_expr.e {: return new List().add(e); :}

  | dim_exprs.l dim_expr.e {: return l.add(e); :}
  ;
dim_expr =
    LBRACK.LBRACK expression.e RBRACK.RBRACK {: return new Dims(new Opt(e)); :}
  ;
dims =
    LBRACK.LBRACK RBRACK.RBRACK {: Dims d = new Dims(new Opt()); d.setStart(LBRACK.getStart()); d.setEnd(RBRACK.getEnd());
                                                  return new List().add(d); :}

  | dims.l LBRACK.LBRACK RBRACK.RBRACK {: Dims d = new Dims(new Opt()); d.setStart(LBRACK.getStart()); d.setEnd(RBRACK.getEnd());
                                                  return l.add(d); :}
  ;
field_access =
    primary.p DOT.DOT simple_name.id {: return p.qualifiesAccess(id); :}

  | SUPER.SUPER DOT.DOT simple_name.id {: SuperAccess s = new SuperAccess();
       s.setStart(SUPER.getStart());
       s.setEnd(SUPER.getEnd());
       return s.qualifiesAccess(id); :}

  | name.n DOT.DOT SUPER.SUPER DOT.DOT_ simple_name.id {: SuperAccess s = new SuperAccess();
       s.setStart(SUPER.getStart());
       s.setEnd(SUPER.getEnd());
       return n.qualifiesAccess(s).qualifiesAccess(id); :}
  ;
method_invocation =
    name.name LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN {: Access result = name.buildMethodAccess(l);
      result.setStart(name.getStart());
      result.setEnd(RPAREN.getEnd());
      return result; :}

  | primary.p DOT.DOT IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN {: MethodAccess m = new MethodAccess(IDENTIFIER, l);
     m.setStart(IDENTIFIER.getStart()); // add location information
     m.setEnd(RPAREN.getEnd()); // add location information
     return p.qualifiesAccess(m); :}

  | SUPER.SUPER DOT.DOT IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN {: SuperAccess s = new SuperAccess();
     s.setStart(SUPER.getStart());
     s.setEnd(SUPER.getEnd());
     MethodAccess m = new MethodAccess(IDENTIFIER, l);
     m.setStart(IDENTIFIER.getStart());
     m.setEnd(RPAREN.getEnd());
     return s.qualifiesAccess(m); :}

  | name.name DOT.DOT SUPER.SUPER DOT.DOT_ IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN {: SuperAccess s = new SuperAccess();
     s.setStart(SUPER.getStart());
     s.setEnd(SUPER.getEnd());
     MethodAccess m = new MethodAccess(IDENTIFIER, l);
     m.setStart(IDENTIFIER.getStart());
     m.setEnd(RPAREN.getEnd());
     return name.qualifiesAccess(s).qualifiesAccess(m); :}
  ;
array_access =
    name.name LBRACK.LBRACK expression.e RBRACK.RBRACK {: ArrayAccess a = new ArrayAccess(e);
     a.setStart(LBRACK.getStart());
     a.setEnd(RBRACK.getEnd());
     return name.qualifiesAccess(a); :}

  | primary_no_new_array.p LBRACK.LBRACK expression.e RBRACK.RBRACK {: ArrayAccess a = new ArrayAccess(e);
     a.setStart(LBRACK.getStart());
     a.setEnd(RBRACK.getEnd());
     return p.qualifiesAccess(a); :}
  ;
postfix_expression =
    primary.primary @ BOTTOM 
  | name.name @ BOTTOM 
  | postincrement_expression.postincrement_expression 
  | postdecrement_expression.postdecrement_expression   ;
postincrement_expression =
    postfix_expression.e PLUSPLUS.PLUSPLUS @ POSTINCDEC {: return new PostIncExpr(e); :}
  ;
postdecrement_expression =
    postfix_expression.e MINUSMINUS.MINUSMINUS @ POSTINCDEC {: return new PostDecExpr(e); :}
  ;
unary_expression =
    preincrement_expression.preincrement_expression 
  | predecrement_expression.predecrement_expression 
  | PLUS.PLUS unary_expression.e @ UNARY {: return new PlusExpr(e); :}

  | MINUS.MINUS unary_expression.e @ UNARY {: return new MinusExpr(e); :}

  | unary_expression_not_plus_minus.unary_expression_not_plus_minus   ;
preincrement_expression =
    PLUSPLUS.PLUSPLUS unary_expression.e {: return new PreIncExpr(e); :}
  ;
predecrement_expression =
    MINUSMINUS.MINUSMINUS unary_expression.e {: return new PreDecExpr(e); :}
  ;
unary_expression_not_plus_minus =
    postfix_expression.postfix_expression @ BOTTOM 
  | COMP.COMP unary_expression.e {: return new BitNotExpr(e); :}

  | NOT.NOT unary_expression.e {: return new LogNotExpr(e); :}

  | cast_expression.cast_expression   ;
cast_expression =
    LPAREN.LPAREN primitive_type.t RPAREN.RPAREN unary_expression.e @ CAST {: return new CastExpr(t.addArrayDims(new List()), e); :}

  | LPAREN.LPAREN primitive_type.t dims.d RPAREN.RPAREN unary_expression.e @ CAST {: return new CastExpr(t.addArrayDims(d), e); :}

  | LPAREN.LPAREN name.t RPAREN.RPAREN unary_expression_not_plus_minus.e @ CAST {: return new CastExpr(t.addArrayDims(new List()), e); :}

  | LPAREN.LPAREN name.t dims.d RPAREN.RPAREN unary_expression_not_plus_minus.e @ CAST {: return new CastExpr(t.addArrayDims(d), e); :}
  ;
multiplicative_expression =
    unary_expression.unary_expression 
  | multiplicative_expression.e1 MULT.MULT unary_expression.e2 {: return new MulExpr(e1, e2); :}

  | multiplicative_expression.e1 DIV.DIV unary_expression.e2 {: return new DivExpr(e1, e2); :}

  | multiplicative_expression.e1 MOD.MOD unary_expression.e2 {: return new ModExpr(e1, e2); :}
  ;
additive_expression =
    multiplicative_expression.multiplicative_expression @ BOTTOM 
  | additive_expression.e1 PLUS.PLUS multiplicative_expression.e2 {: return new AddExpr(e1, e2); :}

  | additive_expression.e1 MINUS.MINUS multiplicative_expression.e2 {: return new SubExpr(e1, e2); :}
  ;
shift_expression =
    additive_expression.additive_expression @ BOTTOM 
  | shift_expression.e1 LSHIFT.LSHIFT additive_expression.e2 {: return new LShiftExpr(e1, e2); :}

  | shift_expression.e1 RSHIFT.RSHIFT additive_expression.e2 {: return new RShiftExpr(e1, e2); :}

  | shift_expression.e1 URSHIFT.URSHIFT additive_expression.e2 {: return new URShiftExpr(e1, e2); :}
  ;
and_expression =
    equality_expression.equality_expression @ BOTTOM 
  | and_expression.e1 AND.AND equality_expression.e2 {: return new AndBitwiseExpr(e1, e2); :}
  ;
exclusive_or_expression =
    and_expression.and_expression @ BOTTOM 
  | exclusive_or_expression.e1 XOR.XOR and_expression.e2 {: return new XorBitwiseExpr(e1, e2); :}
  ;
inclusive_or_expression =
    exclusive_or_expression.exclusive_or_expression @ BOTTOM 
  | inclusive_or_expression.e1 OR.OR exclusive_or_expression.e2 {: return new OrBitwiseExpr(e1, e2); :}
  ;
conditional_and_expression =
    inclusive_or_expression.inclusive_or_expression @ BOTTOM 
  | conditional_and_expression.e1 ANDAND.ANDAND inclusive_or_expression.e2 {: return new AndLogicalExpr(e1, e2); :}
  ;
conditional_or_expression =
    conditional_and_expression.conditional_and_expression @ BOTTOM 
  | conditional_or_expression.e1 OROR.OROR conditional_and_expression.e2 {: return new OrLogicalExpr(e1, e2); :}
  ;
conditional_expression =
    conditional_or_expression.conditional_or_expression @ BOTTOM 
  | conditional_or_expression.c QUESTION.QUESTION expression.e1 COLON.COLON conditional_expression.e2 {: return new ConditionalExpr(c, e1, e2); :}
  ;
assignment_expression =
    conditional_expression.conditional_expression 
  | assignment.assignment   ;
assignment =
    postfix_expression.dest EQ.EQ assignment_expression.source {: return new AssignSimpleExpr(dest, source); :}

  | postfix_expression.dest MULTEQ.MULTEQ assignment_expression.source {: return new AssignMulExpr(dest, source); :}

  | postfix_expression.dest DIVEQ.DIVEQ assignment_expression.source {: return new AssignDivExpr(dest, source); :}

  | postfix_expression.dest MODEQ.MODEQ assignment_expression.source {: return new AssignModExpr(dest, source); :}

  | postfix_expression.dest PLUSEQ.PLUSEQ assignment_expression.source {: return new AssignPlusExpr(dest, source); :}

  | postfix_expression.dest MINUSEQ.MINUSEQ assignment_expression.source {: return new AssignMinusExpr(dest, source); :}

  | postfix_expression.dest LSHIFTEQ.LSHIFTEQ assignment_expression.source {: return new AssignLShiftExpr(dest, source); :}

  | postfix_expression.dest RSHIFTEQ.RSHIFTEQ assignment_expression.source {: return new AssignRShiftExpr(dest, source); :}

  | postfix_expression.dest URSHIFTEQ.URSHIFTEQ assignment_expression.source {: return new AssignURShiftExpr(dest, source); :}

  | postfix_expression.dest ANDEQ.ANDEQ assignment_expression.source {: return new AssignAndExpr(dest, source); :}

  | postfix_expression.dest XOREQ.XOREQ assignment_expression.source {: return new AssignXorExpr(dest, source); :}

  | postfix_expression.dest OREQ.OREQ assignment_expression.source {: return new AssignOrExpr(dest, source); :}
  ;
expression =
    assignment_expression.assignment_expression   ;
constant_expression =
    expression.expression   ;
type_declaration =
    annotation_type_declaration.annotation_type_declaration   ;
interface_member_declaration =
    annotation_type_declaration.i {: MemberInterfaceDecl mid = new MemberInterfaceDecl(i);
     mid.setStart(i.getStart());
     mid.setEnd(i.getEnd());
     return mid; :}
  ;
class_member_declaration =
    annotation_type_declaration.i {: MemberInterfaceDecl mid = new MemberInterfaceDecl(i);
     mid.setStart(i.getStart());
     mid.setEnd(i.getEnd());
     return mid; :}
  ;
annotation_type_declaration =
    AT.AT INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER annotation_type_body.b {: AnnotationDecl a = new AnnotationDecl(new Modifiers(new List()), IDENTIFIER, b);
   a.setStart(new List().getStart());
   a.setEnd(b.getEnd());
   return a; :}

  | modifiers.m AT.AT INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER annotation_type_body.b {: AnnotationDecl a = new AnnotationDecl(new Modifiers(m), IDENTIFIER, b);
   a.setStart(m.getStart());
   a.setEnd(b.getEnd());
   return a; :}
  ;
annotation_type_body =
    LBRACE.LBRACE annotation_type_element_declarations_opt.i RBRACE.RBRACE {: return i; :}
  ;
annotation_type_element_declarations =
    annotation_type_element_declaration.i {: return new List().add(i); :}

  | annotation_type_element_declarations.l annotation_type_element_declaration.i {: return l.add(i); :}
  ;
annotation_type_element_declaration =
    type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN RPAREN.RPAREN default_value_opt.default_value SEMICOLON.SEMICOLON {: AnnotationMethodDecl a = new AnnotationMethodDecl(new Modifiers(new List()), t, IDENTIFIER, new List(), new List(), new Opt(), default_value);
       a.setStart(new List().getStart());
       a.setEnd(SEMICOLON.getEnd());
       return a; :}

  | modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN RPAREN.RPAREN default_value_opt.default_value SEMICOLON.SEMICOLON {: AnnotationMethodDecl a = new AnnotationMethodDecl(new Modifiers(m), t, IDENTIFIER, new List(), new List(), new Opt(), default_value);
       a.setStart(m.getStart());
       a.setEnd(SEMICOLON.getEnd());
       return a; :}

  | constant_declaration.constant_declaration 
  | class_declaration.class_declaration {: MemberClassDecl m = new MemberClassDecl(class_declaration);
       m.setStart(class_declaration.getStart());
       m.setEnd(class_declaration.getEnd());
       return m; :}

  | interface_declaration.interface_declaration {: MemberInterfaceDecl m = new MemberInterfaceDecl(interface_declaration);
       m.setStart(interface_declaration.getStart());
       m.setEnd(interface_declaration.getEnd());
       return m; :}

  | enum_declaration.enum_declaration {: MemberClassDecl m = new MemberClassDecl(enum_declaration);
       m.setStart(enum_declaration.getStart());
       m.setEnd(enum_declaration.getEnd());
       return m; :}

  | annotation_type_declaration.annotation_type_declaration {: MemberInterfaceDecl m = new MemberInterfaceDecl(annotation_type_declaration);
       m.setStart(annotation_type_declaration.getStart());
       m.setEnd(annotation_type_declaration.getEnd());
       return m; :}

  | SEMICOLON.SEMICOLON {: return new StaticInitializer(new Block()); :}
  ;
default_value =
    DEFAULT.DEFAULT element_value.element_value {: return element_value; :}
  ;
modifier =
    annotation.annotation   ;
annotation =
    normal_annotation.normal_annotation 
  | marker_annotation.marker_annotation 
  | single_element_annotation.single_element_annotation   ;
normal_annotation =
    AT.AT name.name LPAREN.LPAREN element_value_pairs_opt.element_value_pairs RPAREN.RPAREN {: Annotation a = new Annotation("annotation", name, element_value_pairs);
     a.setStart(AT.getStart());
     a.setEnd(RPAREN.getEnd());
     return a; :}
  ;
element_value_pairs =
    element_value_pair.element_value_pair {: return new List().add(element_value_pair); :}

  | element_value_pairs.element_value_pairs COMMA.COMMA element_value_pair.element_value_pair {: return element_value_pairs.add(element_value_pair); :}
  ;
element_value_pair =
    IDENTIFIER.IDENTIFIER EQ.EQ element_value.element_value {: ElementValuePair evp = new ElementValuePair(IDENTIFIER, element_value);
     evp.setStart(IDENTIFIER.getStart());
     evp.setEnd(element_value.getEnd());
     return evp; :}
  ;
element_value =
    conditional_expression.conditional_expression {: ElementConstantValue e = new ElementConstantValue(conditional_expression);
       e.setStart(conditional_expression.getStart());
       e.setEnd(conditional_expression.getEnd());
       return e; :}

  | annotation.annotation {: return new ElementAnnotationValue(annotation); :}

  | element_value_array_initializer.element_value_array_initializer   ;
element_value_array_initializer =
    LBRACE.LBRACE RBRACE.RBRACE {: return new ElementArrayValue(new List()); :}

  | LBRACE.LBRACE element_values.element_values RBRACE.RBRACE {: return new ElementArrayValue(element_values); :}

  | LBRACE.LBRACE COMMA.COMMA RBRACE.RBRACE {: return new ElementArrayValue(new List()); :}

  | LBRACE.LBRACE element_values.element_values COMMA.COMMA RBRACE.RBRACE {: return new ElementArrayValue(element_values); :}
  ;
element_values =
    element_value.element_value {: return new List().add(element_value); :}

  | element_values.element_values COMMA.COMMA element_value.element_value {: return element_values.add(element_value); :}
  ;
marker_annotation =
    AT.AT name.name {: return new Annotation("annotation", name, new List()); :}
  ;
single_element_annotation =
    AT.AT name.name LPAREN.LPAREN element_value.element_value RPAREN.RPAREN {: Annotation a = new Annotation("annotation", name, new List().add(new ElementValuePair("value", element_value)));
     a.setStart(AT.getStart());
     a.setEnd(RPAREN.getEnd());
     return a; :}
  ;
compilation_unit =
    modifiers.a package_declaration.p {: return new AnnotatedCompilationUnit(p.getID(), new List(), new List(), new Modifiers(a)); :}

  | modifiers.a package_declaration.p import_declarations.i {: return new AnnotatedCompilationUnit(p.getID(), i, new List(), new Modifiers(a)); :}

  | modifiers.a package_declaration.p type_declarations.t {: return new AnnotatedCompilationUnit(p.getID(), new List(), t, new Modifiers(a)); :}

  | modifiers.a package_declaration.p import_declarations.i type_declarations.t {: return new AnnotatedCompilationUnit(p.getID(), i, t, new Modifiers(a)); :}

  | doc_comments.doc_comments modifiers.a package_declaration.p {: return new AnnotatedCompilationUnit(p.getID(), new List(), new List(), new Modifiers(a)); :}

  | doc_comments.doc_comments modifiers.a package_declaration.p import_declarations.i {: return new AnnotatedCompilationUnit(p.getID(), i, new List(), new Modifiers(a)); :}

  | doc_comments.doc_comments modifiers.a package_declaration.p type_declarations.t {: return new AnnotatedCompilationUnit(p.getID(), new List(), t, new Modifiers(a)); :}

  | doc_comments.doc_comments modifiers.a package_declaration.p import_declarations.i type_declarations.t {: return new AnnotatedCompilationUnit(p.getID(), i, t, new Modifiers(a)); :}
  ;
explicit_constructor_invocation =
    type_arguments.a THIS.THIS LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON {: return new ExprStmt(new ParConstructorAccess("this", l, a)); :}

  | type_arguments.a SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON {: return new ExprStmt(new ParSuperConstructorAccess("super", l, a)); :}

  | primary.p DOT.DOT type_arguments.a SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON {: return new ExprStmt(p.qualifiesAccess(new ParSuperConstructorAccess("super", l, a))); :}

  | name.n DOT.DOT type_arguments.a SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON {: return new ExprStmt(n.qualifiesAccess(new ParSuperConstructorAccess("super", l, a))); :}
  ;
method_invocation =
    primary.p DOT.DOT type_arguments.a IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN {: return p.qualifiesAccess(new ParMethodAccess(IDENTIFIER, l, a)); :}

  | name.n DOT.DOT type_arguments.a IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN {: return n.qualifiesAccess(new ParMethodAccess(IDENTIFIER, l, a)); :}

  | SUPER.SUPER DOT.DOT type_arguments.a IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN {: return new SuperAccess().qualifiesAccess(
                        new ParMethodAccess(IDENTIFIER, l, a)); :}

  | name.n DOT.d1 SUPER.SUPER DOT.d2 type_arguments.a IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN {: return n.qualifiesAccess(new SuperAccess()).qualifiesAccess(
                            new ParMethodAccess(IDENTIFIER, l, a)); :}
  ;
method_header =
    LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN {: return new GenericMethodDecl(new Modifiers(new List()), t.addArrayDims(new List()), IDENTIFIER, p, new List(), new Opt(), l); :}

  | modifiers.m LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN {: return new GenericMethodDecl(new Modifiers(m), t.addArrayDims(new List()), IDENTIFIER, p, new List(), new Opt(), l); :}

  | LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN dims.d {: return new GenericMethodDecl(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER, p, new List(), new Opt(), l); :}

  | modifiers.m LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN dims.d {: return new GenericMethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, p, new List(), new Opt(), l); :}

  | LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN throws.tl {: return new GenericMethodDecl(new Modifiers(new List()), t.addArrayDims(new List()), IDENTIFIER, p, tl, new Opt(), l); :}

  | modifiers.m LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN throws.tl {: return new GenericMethodDecl(new Modifiers(m), t.addArrayDims(new List()), IDENTIFIER, p, tl, new Opt(), l); :}

  | LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN dims.d throws.tl {: return new GenericMethodDecl(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER, p, tl, new Opt(), l); :}

  | modifiers.m LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN dims.d throws.tl {: return new GenericMethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, p, tl, new Opt(), l); :}

  | LT.LT type_parameter_list_1.l VOID.VOID IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN throws_opt.tl {: return new GenericMethodDecl(new Modifiers(new List()), new PrimitiveTypeAccess("void"), IDENTIFIER, p, tl, new Opt(), l); :}

  | modifiers.m LT.LT type_parameter_list_1.l VOID.VOID IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN throws_opt.tl {: return new GenericMethodDecl(new Modifiers(m), new PrimitiveTypeAccess("void"), IDENTIFIER, p, tl, new Opt(), l); :}
  ;
constructor_declaration =
    LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE RBRACE.RBRACE {: return new GenericConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(), new Block(new List()), l); :}

  | modifiers.m LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE RBRACE.RBRACE {: return new GenericConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(), new Block(new List()), l); :}

  | LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c RBRACE.RBRACE {: return new GenericConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(c), new Block(new List()), l); :}

  | modifiers.m LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c RBRACE.RBRACE {: return new GenericConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(c), new Block(new List()), l); :}

  | LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE block_statements.bl RBRACE.RBRACE {: return new GenericConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(), new Block(bl), l); :}

  | modifiers.m LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE block_statements.bl RBRACE.RBRACE {: return new GenericConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(), new Block(bl), l); :}

  | LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c block_statements.bl RBRACE.RBRACE {: return new GenericConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(c), new Block(bl), l); :}

  | modifiers.m LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c block_statements.bl RBRACE.RBRACE {: return new GenericConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(c), new Block(bl), l); :}
  ;
statement =
    enhanced_for_statement.enhanced_for_statement   ;
statement_no_short_if =
    enhanced_for_statement_no_short_if.enhanced_for_statement_no_short_if   ;
enhanced_for_statement =
    FOR.FOR LPAREN.LPAREN type.t enhanced_for_parameter.p COLON.COLON expression.e RPAREN.RPAREN statement.s {: return new EnhancedForStmt(new Modifiers(new List()), t, p, e, s); :}

  | FOR.FOR LPAREN.LPAREN modifiers.m type.t enhanced_for_parameter.p COLON.COLON expression.e RPAREN.RPAREN statement.s {: return new EnhancedForStmt(new Modifiers(m), t, p, e, s); :}
  ;
enhanced_for_statement_no_short_if =
    FOR.FOR LPAREN.LPAREN type.t enhanced_for_parameter.p COLON.COLON expression.e RPAREN.RPAREN statement_no_short_if.s {: return new EnhancedForStmt(new Modifiers(new List()), t, p, e, s); :}

  | FOR.FOR LPAREN.LPAREN modifiers.m type.t enhanced_for_parameter.p COLON.COLON expression.e RPAREN.RPAREN statement_no_short_if.s {: return new EnhancedForStmt(new Modifiers(m), t, p, e, s); :}
  ;
enhanced_for_parameter =
    IDENTIFIER.IDENTIFIER dims_opt.d {: return new VariableDeclarator(IDENTIFIER, d, new Opt()); :}
  ;
primary_no_new_array =
    literal.literal 
  | primitive_type.n DOT.DOT class_literal.c {: return n.addArrayDims(new List()).qualifiesAccess(c); :}

  | primitive_type.n dims.d DOT.DOT class_literal.c {: return n.addArrayDims(d).qualifiesAccess(c); :}

  | name.n DOT.DOT class_literal.c {: return n.addArrayDims(new List()).qualifiesAccess(c); :}

  | name.n dims.d DOT.DOT class_literal.c {: return n.addArrayDims(d).qualifiesAccess(c); :}

  | VOID.VOID DOT.DOT class_literal.c {: PrimitiveTypeAccess v = new PrimitiveTypeAccess("void");
       v.setStart(VOID.getStart());
       v.setEnd(VOID.getEnd());
       return v.qualifiesAccess(c); :}

  | THIS.THIS {: return new ThisAccess(); :}

  | name.n DOT.DOT THIS.THIS {: ThisAccess t = new ThisAccess();
       t.setStart(THIS.getStart()); t.setEnd(THIS.getEnd());
       return n.qualifiesAccess(t); :}

  | LPAREN.LPAREN expression_nn.e RPAREN.RPAREN {: return new ParExpr(e); :}

  | LPAREN.LPAREN name.n RPAREN.RPAREN {: return new ParExpr(n); :}

  | class_instance_creation_expression.class_instance_creation_expression 
  | field_access.field_access 
  | method_invocation.method_invocation 
  | array_access.array_access   ;
postfix_expression_nn =
    primary.primary 
  | postincrement_expression.postincrement_expression 
  | postdecrement_expression.postdecrement_expression   ;
unary_expression_nn =
    preincrement_expression.preincrement_expression 
  | predecrement_expression.predecrement_expression 
  | PLUS.PLUS unary_expression.e @ UNARY {: return new PlusExpr(e); :}

  | MINUS.MINUS unary_expression.e @ UNARY {: return new MinusExpr(e); :}

  | unary_expression_not_plus_minus_nn.unary_expression_not_plus_minus_nn   ;
unary_expression_not_plus_minus_nn =
    postfix_expression_nn.postfix_expression_nn 
  | COMP.COMP unary_expression.e {: return new BitNotExpr(e); :}

  | NOT.NOT unary_expression.e {: return new LogNotExpr(e); :}

  | cast_expression.cast_expression   ;
multiplicative_expression_nn =
    unary_expression_nn.unary_expression_nn 
  | name.e1 MULT.MULT unary_expression.e2 {: return new MulExpr(e1, e2); :}

  | multiplicative_expression_nn.e1 MULT.MULT unary_expression.e2 {: return new MulExpr(e1, e2); :}

  | name.e1 DIV.DIV unary_expression.e2 {: return new DivExpr(e1, e2); :}

  | multiplicative_expression_nn.e1 DIV.DIV unary_expression.e2 {: return new DivExpr(e1, e2); :}

  | name.e1 MOD.MOD unary_expression.e2 {: return new ModExpr(e1, e2); :}

  | multiplicative_expression_nn.e1 MOD.MOD unary_expression.e2 {: return new ModExpr(e1, e2); :}
  ;
additive_expression_nn =
    multiplicative_expression_nn.multiplicative_expression_nn 
  | name.e1 PLUS.PLUS multiplicative_expression.e2 {: return new AddExpr(e1, e2); :}

  | additive_expression_nn.e1 PLUS.PLUS multiplicative_expression.e2 {: return new AddExpr(e1, e2); :}

  | name.e1 MINUS.MINUS multiplicative_expression.e2 {: return new SubExpr(e1, e2); :}

  | additive_expression_nn.e1 MINUS.MINUS multiplicative_expression.e2 {: return new SubExpr(e1, e2); :}
  ;
shift_expression_nn =
    additive_expression_nn.additive_expression_nn 
  | name.e1 LSHIFT.LSHIFT additive_expression.e2 {: return new LShiftExpr(e1, e2); :}

  | shift_expression_nn.e1 LSHIFT.LSHIFT additive_expression.e2 {: return new LShiftExpr(e1, e2); :}

  | name.e1 RSHIFT.RSHIFT additive_expression.e2 {: return new RShiftExpr(e1, e2); :}

  | shift_expression_nn.e1 RSHIFT.RSHIFT additive_expression.e2 {: return new RShiftExpr(e1, e2); :}

  | name.e1 URSHIFT.URSHIFT additive_expression.e2 {: return new URShiftExpr(e1, e2); :}

  | shift_expression_nn.e1 URSHIFT.URSHIFT additive_expression.e2 {: return new URShiftExpr(e1, e2); :}
  ;
relational_expression_nn =
    shift_expression_nn.shift_expression_nn 
  | name.e1 LT.LT shift_expression.e2 {: return new LTExpr(e1, e2); :}

  | shift_expression_nn.e1 LT.LT shift_expression.e2 {: return new LTExpr(e1, e2); :}

  | name.e1 GT.GT shift_expression.e2 {: return new GTExpr(e1, e2); :}

  | shift_expression_nn.e1 GT.GT shift_expression.e2 {: return new GTExpr(e1, e2); :}

  | name.e1 LTEQ.LTEQ shift_expression.e2 {: return new LEExpr(e1, e2); :}

  | relational_expression_nn.e1 LTEQ.LTEQ shift_expression.e2 {: return new LEExpr(e1, e2); :}

  | name.e1 GTEQ.GTEQ shift_expression.e2 {: return new GEExpr(e1, e2); :}

  | relational_expression_nn.e1 GTEQ.GTEQ shift_expression.e2 {: return new GEExpr(e1, e2); :}
  ;
instanceof_expression_nn =
    relational_expression_nn.relational_expression_nn 
  | name.e INSTANCEOF.INSTANCEOF reference_type.t {: return new InstanceOfExpr(e, t); :}

  | shift_expression_nn.e INSTANCEOF.INSTANCEOF reference_type.t {: return new InstanceOfExpr(e, t); :}
  ;
equality_expression_nn =
    instanceof_expression_nn.instanceof_expression_nn 
  | name.e1 EQEQ.EQEQ instanceof_expression.e2 {: return new EQExpr(e1, e2); :}

  | equality_expression_nn.e1 EQEQ.EQEQ instanceof_expression.e2 {: return new EQExpr(e1, e2); :}

  | name.e1 NOTEQ.NOTEQ instanceof_expression.e2 {: return new NEExpr(e1, e2); :}

  | equality_expression_nn.e1 NOTEQ.NOTEQ instanceof_expression.e2 {: return new NEExpr(e1, e2); :}
  ;
relational_expression =
    shift_expression.shift_expression @ BOTTOM 
  | relational_expression.e1 LT.LT shift_expression.e2 {: return new LTExpr(e1, e2); :}

  | relational_expression.e1 GT.GT shift_expression.e2 {: return new GTExpr(e1, e2); :}

  | relational_expression.e1 LTEQ.LTEQ shift_expression.e2 {: return new LEExpr(e1, e2); :}

  | relational_expression.e1 GTEQ.GTEQ shift_expression.e2 {: return new GEExpr(e1, e2); :}
  ;
instanceof_expression =
    relational_expression.relational_expression @ BOTTOM 
  | shift_expression.e INSTANCEOF.INSTANCEOF reference_type.t {: return new InstanceOfExpr(e, t); :}
  ;
equality_expression =
    instanceof_expression.instanceof_expression 
  | equality_expression.e1 EQEQ.EQEQ relational_expression.e2 {: return new EQExpr(e1, e2); :}

  | equality_expression.e1 NOTEQ.NOTEQ relational_expression.e2 {: return new NEExpr(e1, e2); :}
  ;
and_expression_nn =
    equality_expression_nn.equality_expression_nn 
  | name.e1 AND.AND equality_expression.e2 {: return new AndBitwiseExpr(e1, e2); :}

  | and_expression_nn.e1 AND.AND equality_expression.e2 {: return new AndBitwiseExpr(e1, e2); :}
  ;
exclusive_or_expression_nn =
    and_expression_nn.and_expression_nn 
  | name.e1 XOR.XOR and_expression.e2 {: return new XorBitwiseExpr(e1, e2); :}

  | exclusive_or_expression_nn.e1 XOR.XOR and_expression.e2 {: return new XorBitwiseExpr(e1, e2); :}
  ;
inclusive_or_expression_nn =
    exclusive_or_expression_nn.exclusive_or_expression_nn 
  | name.e1 OR.OR exclusive_or_expression.e2 {: return new OrBitwiseExpr(e1, e2); :}

  | inclusive_or_expression_nn.e1 OR.OR exclusive_or_expression.e2 {: return new OrBitwiseExpr(e1, e2); :}
  ;
conditional_and_expression_nn =
    inclusive_or_expression_nn.inclusive_or_expression_nn 
  | name.e1 ANDAND.ANDAND inclusive_or_expression.e2 {: return new AndLogicalExpr(e1, e2); :}

  | conditional_and_expression_nn.e1 ANDAND.ANDAND inclusive_or_expression.e2 {: return new AndLogicalExpr(e1, e2); :}
  ;
conditional_or_expression_nn =
    conditional_and_expression_nn.e {: return e; :}

  | name.e1 OROR.OROR conditional_and_expression.e2 {: return new OrLogicalExpr(e1, e2); :}

  | conditional_or_expression_nn.e1 OROR.OROR conditional_and_expression.e2 {: return new OrLogicalExpr(e1, e2); :}
  ;
conditional_expression_nn =
    conditional_or_expression_nn.conditional_or_expression_nn 
  | name.c QUESTION.QUESTION expression.e1 COLON.COLON conditional_expression.e2 {: return new ConditionalExpr(c, e1, e2); :}

  | conditional_or_expression_nn.c QUESTION.QUESTION expression.e1 COLON.COLON conditional_expression.e2 {: return new ConditionalExpr(c, e1, e2); :}
  ;
assignment_expression_nn =
    conditional_expression_nn.conditional_expression_nn 
  | assignment.assignment   ;
expression_nn =
    assignment_expression_nn.assignment_expression_nn   ;
formal_parameter =
    type.t ELLIPSIS.ELLIPSIS IDENTIFIER.IDENTIFIER dims_opt.d {: return new VariableArityParameterDeclaration(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER); :}

  | modifiers.m type.t ELLIPSIS.ELLIPSIS IDENTIFIER.IDENTIFIER dims_opt.d {: return new VariableArityParameterDeclaration(new Modifiers(m), t.addArrayDims(d), IDENTIFIER); :}
  ;
class_declaration =
    CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p class_body.b {: return new GenericClassDecl(new Modifiers(new List()), IDENTIFIER, new Opt(), new List(), b, p); :}

  | modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p class_body.b {: return new GenericClassDecl(new Modifiers(m), IDENTIFIER, new Opt(), new List(), b, p); :}

  | CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p super.s class_body.b {: return new GenericClassDecl(new Modifiers(new List()), IDENTIFIER, s, new List(), b, p); :}

  | modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p super.s class_body.b {: return new GenericClassDecl(new Modifiers(m), IDENTIFIER, s, new List(), b, p); :}

  | CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p interfaces.i class_body.b {: return new GenericClassDecl(new Modifiers(new List()), IDENTIFIER, new Opt(), i, b, p); :}

  | modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p interfaces.i class_body.b {: return new GenericClassDecl(new Modifiers(m), IDENTIFIER, new Opt(), i, b, p); :}

  | CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p super.s interfaces.i class_body.b {: return new GenericClassDecl(new Modifiers(new List()), IDENTIFIER, s, i, b, p); :}

  | modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p super.s interfaces.i class_body.b {: return new GenericClassDecl(new Modifiers(m), IDENTIFIER, s, i, b, p); :}
  ;
interface_declaration =
    INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER type_parameters.p interface_body.b {: return new GenericInterfaceDecl(new Modifiers(new List()), IDENTIFIER, new List(), b, p); :}

  | modifiers.m INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER type_parameters.p interface_body.b {: return new GenericInterfaceDecl(new Modifiers(m), IDENTIFIER, new List(), b, p); :}

  | INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER type_parameters.p extends_interfaces.i interface_body.b {: return new GenericInterfaceDecl(new Modifiers(new List()), IDENTIFIER, i, b, p); :}

  | modifiers.m INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER type_parameters.p extends_interfaces.i interface_body.b {: return new GenericInterfaceDecl(new Modifiers(m), IDENTIFIER, i, b, p); :}
  ;
class_or_interface =
    name.name @ BOTTOM 
  | class_or_interface.n LT.LT type_argument_list_1.l DOT.DOT name.end {: return new ParTypeAccess(n, l).qualifiesAccess(end); :}
  ;
class_or_interface_type =
    class_or_interface.class_or_interface @ BOTTOM 
  | class_or_interface.n LT.LT type_argument_list_1.l {: return new ParTypeAccess(n, l); :}
  ;
array_type =
    class_or_interface.t LT.LT type_argument_list_1.l DOT.DOT name.n dims.d {: return new ParTypeAccess(t, l).qualifiesAccess(n).addArrayDims(d); :}

  | class_or_interface.t LT.LT type_argument_list_1.l dims.d {: return new ParTypeAccess(t, l).addArrayDims(d); :}
  ;
type_arguments =
    LT.LT type_argument_list_1.l {: return l; :}
  ;
wildcard =
    QUESTION.QUESTION {: return new Wildcard(); :}

  | QUESTION.QUESTION EXTENDS.EXTENDS reference_type.t {: return new WildcardExtends(t); :}

  | QUESTION.QUESTION SUPER.SUPER reference_type.t {: return new WildcardSuper(t); :}
  ;
wildcard_1 =
    QUESTION.QUESTION GT.GT {: return new Wildcard(); :}

  | QUESTION.QUESTION EXTENDS.EXTENDS reference_type_1.t {: return new WildcardExtends(t); :}

  | QUESTION.QUESTION SUPER.SUPER reference_type_1.t {: return new WildcardSuper(t); :}
  ;
wildcard_2 =
    QUESTION.QUESTION RSHIFT.RSHIFT {: return new Wildcard(); :}

  | QUESTION.QUESTION EXTENDS.EXTENDS reference_type_2.t {: return new WildcardExtends(t); :}

  | QUESTION.QUESTION SUPER.SUPER reference_type_2.t {: return new WildcardSuper(t); :}
  ;
wildcard_3 =
    QUESTION.QUESTION URSHIFT.URSHIFT {: return new Wildcard(); :}

  | QUESTION.QUESTION EXTENDS.EXTENDS reference_type_3.t {: return new WildcardExtends(t); :}

  | QUESTION.QUESTION SUPER.SUPER reference_type_3.t {: return new WildcardSuper(t); :}
  ;
class_instance_creation_expression =
    NEW.NEW class_or_interface_type.t LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b {: return new ClassInstanceExpr(t, l, b); :}

  | NEW.NEW type_arguments.a class_or_interface_type.t LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b {: return new ParClassInstanceExpr(t, l, b, a); :}

  | primary.n DOT.DOT NEW.NEW simple_name.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b {: ClassInstanceExpr e = new ClassInstanceExpr(id, l, b);
        e.setStart(NEW.getStart());
        e.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(e); :}

  | primary.n DOT.DOT NEW.NEW simple_name.id type_arguments.a LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b {: ClassInstanceExpr e = new ClassInstanceExpr(new ParTypeAccess(id, a), l, b);
        e.setStart(NEW.getStart());
        e.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(e); :}

  | primary.n DOT.DOT NEW.NEW type_arguments.ca simple_name.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b {: return n.qualifiesAccess(new ParClassInstanceExpr(id, l, b, ca)); :}

  | primary.n DOT.DOT NEW.NEW type_arguments.ca simple_name.id type_arguments.ta LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b {: return n.qualifiesAccess(new ParClassInstanceExpr(new ParTypeAccess(id, ta), l, b, ca)); :}

  | name.n DOT.DOT NEW.NEW simple_name.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b {: ClassInstanceExpr e = new ClassInstanceExpr(id, l, b);
        e.setStart(NEW.getStart());
        e.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(e); :}

  | name.n DOT.DOT NEW.NEW simple_name.id type_arguments.a LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b {: ClassInstanceExpr e = new ClassInstanceExpr(new ParTypeAccess(id, a), l, b);
        e.setStart(NEW.getStart());
        e.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(e); :}

  | name.n DOT.DOT NEW.NEW type_arguments.ca simple_name.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b {: return n.qualifiesAccess(new ParClassInstanceExpr(id, l, b, ca)); :}

  | name.n DOT.DOT NEW.NEW type_arguments.ca simple_name.id type_arguments.ta LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b {: return n.qualifiesAccess(new ParClassInstanceExpr(new ParTypeAccess(id, ta), l, b, ca)); :}
  ;
type_argument_list =
    type_argument.a {: return new List().add(a); :}

  | type_argument_list.l COMMA.COMMA type_argument.a {: return l.add(a); :}
  ;
type_argument_list_1 =
    type_argument_1.a {: return new List().add(a); :}

  | type_argument_list.l COMMA.COMMA type_argument_1.a {: return l.add(a); :}
  ;
type_argument_list_2 =
    type_argument_2.a {: return new List().add(a); :}

  | type_argument_list.l COMMA.COMMA type_argument_2.a {: return l.add(a); :}
  ;
type_argument_list_3 =
    type_argument_3.a {: return new List().add(a); :}

  | type_argument_list.l COMMA.COMMA type_argument_3.a {: return l.add(a); :}
  ;
type_argument =
    reference_type.t {: return t; :}

  | wildcard.w {: return w; :}
  ;
type_argument_1 =
    reference_type_1.t {: return t; :}

  | wildcard_1.w {: return w; :}
  ;
type_argument_2 =
    reference_type_2.t {: return t; :}

  | wildcard_2.w {: return w; :}
  ;
type_argument_3 =
    reference_type_3.t {: return t; :}

  | wildcard_3.w {: return w; :}
  ;
reference_type_1 =
    reference_type.t GT.GT {: return t; :}

  | class_or_interface.t LT.LT type_argument_list_2.l {: return new ParTypeAccess(t, l); :}
  ;
reference_type_2 =
    reference_type.t RSHIFT.RSHIFT {: return t; :}

  | class_or_interface.t LT.LT type_argument_list_3.l {: return new ParTypeAccess(t, l); :}
  ;
reference_type_3 =
    reference_type.t URSHIFT.URSHIFT {: return t; :}
  ;
cast_expression =
    LPAREN.LPAREN name.n LT.LT type_argument_list_1.a RPAREN.RPAREN unary_expression_not_plus_minus.e @ CAST {: return new CastExpr(new ParTypeAccess(n, a).addArrayDims(new List()), e); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a dims.d RPAREN.RPAREN unary_expression_not_plus_minus.e @ CAST {: return new CastExpr(new ParTypeAccess(n, a).addArrayDims(d), e); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t RPAREN.RPAREN unary_expression_not_plus_minus.e @ CAST {: return new CastExpr(new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(new List()), e); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t dims.d RPAREN.RPAREN unary_expression_not_plus_minus.e @ CAST {: return new CastExpr(new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(d), e); :}
  ;
type_parameters =
    LT.LT type_parameter_list_1.l {: return l; :}
  ;
type_parameter_list =
    type_parameter_list.l COMMA.COMMA type_parameter.p {: return l.add(p); :}

  | type_parameter.p {: return new List().add(p); :}
  ;
type_parameter_list_1 =
    type_parameter_1.p {: return new List().add(p); :}

  | type_parameter_list.l COMMA.COMMA type_parameter_1.p {: return l.add(p); :}
  ;
type_parameter =
    IDENTIFIER.IDENTIFIER {: return new TypeVariable(new Modifiers(), IDENTIFIER, new List(), new List()); :}

  | IDENTIFIER.IDENTIFIER type_bound.l {: return new TypeVariable(new Modifiers(), IDENTIFIER, new List(), l); :}
  ;
type_parameter_1 =
    IDENTIFIER.IDENTIFIER GT.GT {: return new TypeVariable(new Modifiers(), IDENTIFIER, new List(), new List()); :}

  | IDENTIFIER.IDENTIFIER type_bound_1.l {: return new TypeVariable(new Modifiers(), IDENTIFIER, new List(), l); :}
  ;
type_bound =
    EXTENDS.EXTENDS reference_type.t {: return new List().add(t); :}

  | EXTENDS.EXTENDS reference_type.t additional_bound_list.l {: l.insertChild(t,0); return l; :}
  ;
type_bound_1 =
    EXTENDS.EXTENDS reference_type_1.t {: return new List().add(t); :}

  | EXTENDS.EXTENDS reference_type.t additional_bound_list_1.l {: l.insertChild(t,0); return l; :}
  ;
additional_bound_list =
    additional_bound.b additional_bound_list.l {: l.insertChild(b,0); return l; :}

  | additional_bound.b {: return new List().add(b); :}
  ;
additional_bound_list_1 =
    additional_bound.b additional_bound_list_1.l {: l.insertChild(b,0); return l; :}

  | additional_bound_1.b {: return new List().add(b); :}
  ;
additional_bound =
    AND.AND interface_type.t {: return t; :}
  ;
additional_bound_1 =
    AND.AND reference_type_1.t {: return t; :}
  ;
import_declaration =
    single_static_import_declaration.single_static_import_declaration 
  | static_import_on_demand_declaration.static_import_on_demand_declaration   ;
single_static_import_declaration =
    IMPORT.IMPORT STATIC.STATIC name.n DOT.DOT IDENTIFIER.IDENTIFIER SEMICOLON.SEMICOLON {: return new SingleStaticImportDecl(n, IDENTIFIER); :}
  ;
static_import_on_demand_declaration =
    IMPORT.IMPORT STATIC.STATIC name.n DOT.DOT MULT.MULT SEMICOLON.SEMICOLON {: return new StaticImportOnDemandDecl(n); :}
  ;
type_declaration =
    enum_declaration.enum_declaration   ;
interface_member_declaration =
    enum_declaration.i {: return new MemberClassDecl(i); :}
  ;
class_member_declaration =
    enum_declaration.i {: return new MemberClassDecl(i); :}
  ;
enum_declaration =
    ENUM.ENUM IDENTIFIER.id enum_body.b {: return new EnumDecl(new Modifiers(new List()), ((String)id.value), new List(), b); :}

  | modifiers.m ENUM.ENUM IDENTIFIER.id enum_body.b {: return new EnumDecl(new Modifiers(m), ((String)id.value), new List(), b); :}

  | ENUM.ENUM IDENTIFIER.id interfaces.i enum_body.b {: return new EnumDecl(new Modifiers(new List()), ((String)id.value), i, b); :}

  | modifiers.m ENUM.ENUM IDENTIFIER.id interfaces.i enum_body.b {: return new EnumDecl(new Modifiers(m), ((String)id.value), i, b); :}
  ;
enum_body =
    LBRACE.LBRACE RBRACE.RBRACE {: return new List(); :}

  | LBRACE.LBRACE enum_constants.enum_constants RBRACE.RBRACE {: return enum_constants; :}

  | LBRACE.LBRACE COMMA.COMMA RBRACE.RBRACE {: return new List(); :}

  | LBRACE.LBRACE enum_constants.enum_constants COMMA.COMMA RBRACE.RBRACE {: return enum_constants; :}

  | LBRACE.LBRACE enum_body_declarations.enum_body_declarations RBRACE.RBRACE {: return enum_body_declarations; :}

  | LBRACE.LBRACE enum_constants.c enum_body_declarations.d RBRACE.RBRACE {: for(int i = 0; i < d.getNumChildNoTransform(); i++) c.add(d.getChildNoTransform(i)); return c; :}

  | LBRACE.LBRACE COMMA.COMMA enum_body_declarations.enum_body_declarations RBRACE.RBRACE {: return enum_body_declarations; :}

  | LBRACE.LBRACE enum_constants.c COMMA.COMMA enum_body_declarations.d RBRACE.RBRACE {: for(int i = 0; i < d.getNumChildNoTransform(); i++) c.add(d.getChildNoTransform(i)); return c; :}
  ;
enum_constants =
    enum_constant.enum_constant {: return new List().add(enum_constant); :}

  | enum_constants.enum_constants COMMA.COMMA enum_constant.enum_constant {: return enum_constants.add(enum_constant); :}
  ;
enum_constant =
    IDENTIFIER.id {: return new EnumConstant(new Modifiers(new List()), ((String)id.value), new List(), new List()); :}

  | annotations.annotations IDENTIFIER.id {: return new EnumConstant(new Modifiers(annotations), ((String)id.value), new List(), new List()); :}

  | IDENTIFIER.id arguments.arguments {: return new EnumConstant(new Modifiers(new List()), ((String)id.value), arguments, new List()); :}

  | annotations.annotations IDENTIFIER.id arguments.arguments {: return new EnumConstant(new Modifiers(annotations), ((String)id.value), arguments, new List()); :}

  | IDENTIFIER.id class_body.class_body {: return new EnumConstant(new Modifiers(new List()), ((String)id.value), new List(), class_body); :}

  | annotations.annotations IDENTIFIER.id class_body.class_body {: return new EnumConstant(new Modifiers(annotations), ((String)id.value), new List(), class_body); :}

  | IDENTIFIER.id arguments.arguments class_body.class_body {: return new EnumConstant(new Modifiers(new List()), ((String)id.value), arguments, class_body); :}

  | annotations.annotations IDENTIFIER.id arguments.arguments class_body.class_body {: return new EnumConstant(new Modifiers(annotations), ((String)id.value), arguments, class_body); :}
  ;
arguments =
    LPAREN.LPAREN argument_list.argument_list RPAREN.RPAREN {: return argument_list; :}

  | LPAREN.LPAREN RPAREN.RPAREN {: return new List(); :}
  ;
annotations =
    annotation.annotation {: return new List().add(annotation); :}

  | annotations.annotations annotation.annotation {: return annotations.add(annotation); :}
  ;
enum_body_declarations =
    SEMICOLON.SEMICOLON doc_comments_opt.doc_comments_opt {: return new List(); :}

  | SEMICOLON.SEMICOLON class_body_declarations.class_body_declarations doc_comments_opt.doc_comments_opt {: return class_body_declarations; :}
  ;
literal =
    NUMERIC_LITERAL.NUMERIC_LITERAL {: return NumericLiteralParser.parse("" + NUMERIC_LITERAL.value); :}

  | BOOLEAN_LITERAL.BOOLEAN_LITERAL {: return new BooleanLiteral(BOOLEAN_LITERAL); :}

  | CHARACTER_LITERAL.CHARACTER_LITERAL {: return new CharacterLiteral(CHARACTER_LITERAL); :}

  | STRING_LITERAL.STRING_LITERAL {: return new StringLiteral(STRING_LITERAL); :}

  | NULL_LITERAL.NULL_LITERAL {: return new NullLiteral(NULL_LITERAL); :}
  ;
class_or_interface_type =
    class_or_interface.class_or_interface LT.LT GT.GT {: return new DiamondAccess(class_or_interface); :}
  ;
statement =
    try_with_resource.try_with_resource   ;
try_with_resource =
    TRY.TRY LPAREN.LPAREN resource_list.a RPAREN.RPAREN block.b {: return new TryWithResources(a, b, new List(), new Opt()); :}

  | TRY.TRY LPAREN.LPAREN resource_list.a RPAREN.RPAREN block.b catches.c {: return new TryWithResources(a, b, c, new Opt()); :}

  | TRY.TRY LPAREN.LPAREN resource_list.a RPAREN.RPAREN block.b finally.c {: return new TryWithResources(a, b, new List(), new Opt(c)); :}

  | TRY.TRY LPAREN.LPAREN resource_list.a RPAREN.RPAREN block.b catches.c finally.d {: return new TryWithResources(a, b, c, new Opt(d)); :}
  ;
resource_list =
    resources.a {: return a; :}

  | resources.a SEMICOLON.SEMICOLON {: return a; :}
  ;
resources =
    resource.a {: return new List().add(a); :}

  | resources.a SEMICOLON.SEMICOLON resource.b {: return a.add(b); :}
  ;
resource =
    resource_declaration.a {: return a ; :}
  ;
resource_declaration =
    type.b IDENTIFIER.IDENTIFIER EQ.EQ variable_initializer.i {: return new ResourceDeclaration(new VariableDeclarator(IDENTIFIER, new List(), new Opt(i)), new ResourceModifiers(new List()), b); :}

  | modifiers.a type.b IDENTIFIER.IDENTIFIER EQ.EQ variable_initializer.i {: return new ResourceDeclaration(new VariableDeclarator(IDENTIFIER, new List(), new Opt(i)), new ResourceModifiers(a), b); :}
  ;
catch_clause =
    CATCH.CATCH LPAREN.LPAREN multi_catch_param.p RPAREN.RPAREN block.b {: return new MultiCatch(p, b); :}
  ;
multi_catch_param =
    multi_catch_type.b IDENTIFIER.IDENTIFIER dims_opt.c {: return new CatchParameterDeclaration(new Modifiers(new List()), b, IDENTIFIER); :}

  | modifiers.a multi_catch_type.b IDENTIFIER.IDENTIFIER dims_opt.c {: return new CatchParameterDeclaration(new Modifiers(a), b, IDENTIFIER); :}
  ;
multi_catch_type =
    type.a OR.OR type.b {: return new List().add(a).add(b); :}

  | multi_catch_type.a OR.OR type.b {: return a.add(b); :}
  ;
primary_no_new_array =
    constructor_reference.constructor_reference   ;
constructor_reference =
    name.n DOUBLECOLON.DOUBLECOLON type_arguments_opt.a NEW.NEW {: return new ClassReference(n, a); :}

  | name.n LTTYPE.LTTYPE type_argument_list_1.a1 DOUBLECOLON.DOUBLECOLON type_arguments_opt.a2 NEW.NEW {: return new ClassReference(new ParTypeAccess(n, a1), a2); :}
  ;
constructor_reference =
    nongeneric_array_type.r DOUBLECOLON.DOUBLECOLON NEW.NEW {: return new ArrayReference(r); :}

  | name.n LTTYPE.LTTYPE type_argument_list_1.a dims.d DOUBLECOLON.DOUBLECOLON NEW.NEW {: return new ArrayReference(new ParTypeAccess(n, a).addArrayDims(d)); :}
  ;
primary_no_new_array =
    method_reference.method_reference   ;
method_reference =
    primary.p DOUBLECOLON.DOUBLECOLON type_arguments_opt.a IDENTIFIER.i {: return new ExprMethodReference(a, ((String)i.value), p); :}
  ;
method_reference =
    name.n DOT.DOT SUPER.SUPER DOUBLECOLON.DOUBLECOLON type_arguments_opt.a IDENTIFIER.i {: SuperAccess s = new SuperAccess();
           s.setStart(SUPER.getStart());
           s.setEnd(SUPER.getEnd()); 
		   return new ExprMethodReference(a, ((String)i.value), n.qualifiesAccess(s)); :}

  | SUPER.SUPER DOUBLECOLON.DOUBLECOLON type_arguments_opt.a IDENTIFIER.i {: SuperAccess s = new SuperAccess();
		   s.setStart(SUPER.getStart());
		   s.setEnd(SUPER.getEnd());
		   return new ExprMethodReference(a, ((String)i.value), s); :}
  ;
method_reference =
    nongeneric_array_type.r DOUBLECOLON.DOUBLECOLON type_arguments_opt.a IDENTIFIER.i {: return new TypeMethodReference(a, ((String)i.value), r); :}

  | name.n LTTYPE.LTTYPE type_argument_list_1.a1 DOUBLECOLON.DOUBLECOLON type_arguments_opt.a2 IDENTIFIER.i {: return new TypeMethodReference(a2, ((String)i.value), new ParTypeAccess(n, a1).addArrayDims(new List())); :}

  | name.n LTTYPE.LTTYPE type_argument_list_1.a1 dims.d DOUBLECOLON.DOUBLECOLON type_arguments_opt.a2 IDENTIFIER.i {: return new TypeMethodReference(a2, ((String)i.value), new ParTypeAccess(n, a1).addArrayDims(d)); :}
  ;
method_reference =
    name.n DOUBLECOLON.DOUBLECOLON type_arguments_opt.a IDENTIFIER.i {: return new AmbiguousMethodReference(a, ((String)i.value), n); :}
  ;
cast_expression =
    LPAREN.LPAREN name.n LT.LT type_argument_list_1.a additional_bound_list.b RPAREN.RPAREN unary_expression_not_plus_minus.e @ CAST {: return new IntersectionCastExpr(new ParTypeAccess(n, a).addArrayDims(new List()), b, e); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a dims.d additional_bound_list.b RPAREN.RPAREN unary_expression_not_plus_minus.e @ CAST {: return new IntersectionCastExpr(new ParTypeAccess(n, a).addArrayDims(d), b, e); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t additional_bound_list.b RPAREN.RPAREN unary_expression_not_plus_minus.e @ CAST {: return new IntersectionCastExpr(new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(new List()), b, e); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t dims.d additional_bound_list.b RPAREN.RPAREN unary_expression_not_plus_minus.e @ CAST {: return new IntersectionCastExpr(new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(d), b, e); :}
  ;
cast_expression =
    INTERCAST.INTERCAST LPAREN.LPAREN name.t additional_bound_list.b RPAREN.RPAREN unary_expression_not_plus_minus.e @ CAST {: return new IntersectionCastExpr(t.addArrayDims(new List()), b, e); :}

  | INTERCAST.INTERCAST LPAREN.LPAREN name.t dims.d additional_bound_list.b RPAREN.RPAREN unary_expression_not_plus_minus.e @ CAST {: return new IntersectionCastExpr(t.addArrayDims(d), b, e); :}
  ;
modifier =
    PACKAGE.PACKAGE {: return new Modifier("package"); :}
  ;
nongeneric_type =
    primitive_type.primitive_type 
  | nongeneric_reference_type.nongeneric_reference_type   ;
nongeneric_reference_type =
    nongeneric_class_or_interface_type.nongeneric_class_or_interface_type 
  | nongeneric_array_type.nongeneric_array_type   ;
nongeneric_class_or_interface_type =
    name.name   ;
nongeneric_array_type =
    primitive_type.t dims.dims {: return t.addArrayDims(dims); :}

  | name.name dims.dims {: return name.addArrayDims(dims); :}
  ;
nongeneric_formal_parameter =
    nongeneric_type.t IDENTIFIER.IDENTIFIER dims_opt.d {: return new ParameterDeclaration(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER); :}

  | modifiers.m nongeneric_type.t IDENTIFIER.IDENTIFIER dims_opt.d {: return new ParameterDeclaration(new Modifiers(m), t.addArrayDims(d), IDENTIFIER); :}

  | nongeneric_type.t ELLIPSIS.ELLIPSIS IDENTIFIER.i {: return new VariableArityParameterDeclaration(new Modifiers(new List()), t, ((String)i.value)); :}

  | modifiers.m nongeneric_type.t ELLIPSIS.ELLIPSIS IDENTIFIER.i {: return new VariableArityParameterDeclaration(new Modifiers(m), t, ((String)i.value)); :}
  ;
primary_no_new_array =
    lambda_expression.lambda_expression   ;
lambda_expression =
    LPAREN.LPAREN RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new DeclaredLambdaParameters(new List()), b); :}
  ;
lambda_expression =
    IDENTIFIER.i RARROW.RARROW lambda_body.b {: return new LambdaExpr(new InferredLambdaParameters(new List().add(new InferredParameterDeclaration(((String)i.value)))), b); :}
  ;
lambda_expression =
    INFERRED_LAMBDA.INFERRED_LAMBDA LPAREN.LPAREN IDENTIFIER.i RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new InferredLambdaParameters(new List().add(new InferredParameterDeclaration(((String)i.value)))), b); :}
  ;
lambda_expression =
    LPAREN.LPAREN IDENTIFIER.i COMMA.COMMA inferred_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new InferredParameterDeclaration(((String)i.value)));
			for(Object o : l) list.add((InferredParameterDeclaration)o);
		return new LambdaExpr(new InferredLambdaParameters(list), b); :}
  ;
lambda_expression =
    LPAREN.LPAREN nongeneric_formal_parameter.f RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new DeclaredLambdaParameters(new List().add(f)), b); :}

  | LPAREN.LPAREN nongeneric_formal_parameter.f comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(f);
			for(Object o : l) list.add((ParameterDeclaration)o); 
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a IDENTIFIER.i dims_opt.d2 RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new DeclaredLambdaParameters(
			new List().add(new ParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).addArrayDims(new List()).addArrayDims(d2), ((String)i.value)))), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a IDENTIFIER.i dims_opt.d2 RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new DeclaredLambdaParameters(
			new List().add(new ParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).addArrayDims(new List()).addArrayDims(d2), ((String)i.value)))), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a dims.d1 IDENTIFIER.i dims_opt.d2 RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new DeclaredLambdaParameters(
			new List().add(new ParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).addArrayDims(d1).addArrayDims(d2), ((String)i.value)))), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a dims.d1 IDENTIFIER.i dims_opt.d2 RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new DeclaredLambdaParameters(
			new List().add(new ParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).addArrayDims(d1).addArrayDims(d2), ((String)i.value)))), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a IDENTIFIER.i comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new ParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).addArrayDims(new List()).addArrayDims(new List()), ((String)i.value)));
			for(Object o : l) list.add((ParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a IDENTIFIER.i comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new ParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).addArrayDims(new List()).addArrayDims(new List()), ((String)i.value)));
			for(Object o : l) list.add((ParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a dims.d1 IDENTIFIER.i comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new ParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).addArrayDims(d1).addArrayDims(new List()), ((String)i.value)));
			for(Object o : l) list.add((ParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a dims.d1 IDENTIFIER.i comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new ParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).addArrayDims(d1).addArrayDims(new List()), ((String)i.value)));
			for(Object o : l) list.add((ParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a IDENTIFIER.i dims.d2 comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new ParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).addArrayDims(new List()).addArrayDims(d2), ((String)i.value)));
			for(Object o : l) list.add((ParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a IDENTIFIER.i dims.d2 comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new ParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).addArrayDims(new List()).addArrayDims(d2), ((String)i.value)));
			for(Object o : l) list.add((ParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a dims.d1 IDENTIFIER.i dims.d2 comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new ParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).addArrayDims(d1).addArrayDims(d2), ((String)i.value)));
			for(Object o : l) list.add((ParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a dims.d1 IDENTIFIER.i dims.d2 comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new ParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).addArrayDims(d1).addArrayDims(d2), ((String)i.value)));
			for(Object o : l) list.add((ParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t IDENTIFIER.i dims_opt.d2 RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new DeclaredLambdaParameters(
			new List().add(new ParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(new List()).addArrayDims(d2), ((String)i.value)))), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t IDENTIFIER.i dims_opt.d2 RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new DeclaredLambdaParameters(
			new List().add(new ParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(new List()).addArrayDims(d2), ((String)i.value)))), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t dims.d1 IDENTIFIER.i dims_opt.d2 RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new DeclaredLambdaParameters(
			new List().add(new ParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(d1).addArrayDims(d2), ((String)i.value)))), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t dims.d1 IDENTIFIER.i dims_opt.d2 RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new DeclaredLambdaParameters(
			new List().add(new ParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(d1).addArrayDims(d2), ((String)i.value)))), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t IDENTIFIER.i comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new ParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(new List()).addArrayDims(new List()), ((String)i.value)));
			for(Object o : l) list.add((ParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t IDENTIFIER.i comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new ParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(new List()).addArrayDims(new List()), ((String)i.value)));
			for(Object o : l) list.add((ParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t dims.d1 IDENTIFIER.i comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new ParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(d1).addArrayDims(new List()), ((String)i.value)));
			for(Object o : l) list.add((ParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t dims.d1 IDENTIFIER.i comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new ParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(d1).addArrayDims(new List()), ((String)i.value)));
			for(Object o : l) list.add((ParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t IDENTIFIER.i dims.d2 comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new ParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(new List()).addArrayDims(d2), ((String)i.value)));
			for(Object o : l) list.add((ParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t IDENTIFIER.i dims.d2 comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new ParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(new List()).addArrayDims(d2), ((String)i.value)));
			for(Object o : l) list.add((ParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t dims.d1 IDENTIFIER.i dims.d2 comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new ParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(d1).addArrayDims(d2), ((String)i.value)));
			for(Object o : l) list.add((ParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t dims.d1 IDENTIFIER.i dims.d2 comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new ParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(d1).addArrayDims(d2), ((String)i.value)));
			for(Object o : l) list.add((ParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a ELLIPSIS.ELLIPSIS IDENTIFIER.i RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new DeclaredLambdaParameters(
			new List().add(new VariableArityParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).addArrayDims(new List()), ((String)i.value)))), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a ELLIPSIS.ELLIPSIS IDENTIFIER.i RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new DeclaredLambdaParameters(
			new List().add(new VariableArityParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).addArrayDims(new List()), ((String)i.value)))), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a dims.d1 ELLIPSIS.ELLIPSIS IDENTIFIER.i RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new DeclaredLambdaParameters(
			new List().add(new VariableArityParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).addArrayDims(d1), ((String)i.value)))), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a dims.d1 ELLIPSIS.ELLIPSIS IDENTIFIER.i RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new DeclaredLambdaParameters(
			new List().add(new VariableArityParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).addArrayDims(d1), ((String)i.value)))), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a ELLIPSIS.ELLIPSIS IDENTIFIER.i comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new VariableArityParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).addArrayDims(new List()), ((String)i.value)));
			for(Object o : l) list.add((VariableArityParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a ELLIPSIS.ELLIPSIS IDENTIFIER.i comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new VariableArityParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).addArrayDims(new List()), ((String)i.value)));
			for(Object o : l) list.add((VariableArityParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a dims.d1 ELLIPSIS.ELLIPSIS IDENTIFIER.i comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new VariableArityParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).addArrayDims(d1), ((String)i.value)));
			for(Object o : l) list.add((VariableArityParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a dims.d1 ELLIPSIS.ELLIPSIS IDENTIFIER.i comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new VariableArityParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).addArrayDims(d1), ((String)i.value)));
			for(Object o : l) list.add((VariableArityParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t ELLIPSIS.ELLIPSIS IDENTIFIER.i RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new DeclaredLambdaParameters(
			new List().add(new VariableArityParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(new List()), ((String)i.value)))), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t ELLIPSIS.ELLIPSIS IDENTIFIER.i RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new DeclaredLambdaParameters(
			new List().add(new VariableArityParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(new List()), ((String)i.value)))), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t dims.d1 ELLIPSIS.ELLIPSIS IDENTIFIER.i RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new DeclaredLambdaParameters(
			new List().add(new VariableArityParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(d1), ((String)i.value)))), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t dims.d1 ELLIPSIS.ELLIPSIS IDENTIFIER.i RPAREN.RPAREN RARROW.RARROW lambda_body.b {: return new LambdaExpr(new DeclaredLambdaParameters(
			new List().add(new VariableArityParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(d1), ((String)i.value)))), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t ELLIPSIS.ELLIPSIS IDENTIFIER.i comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new VariableArityParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(new List()), ((String)i.value))); 
			for(Object o : l) list.add((VariableArityParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t ELLIPSIS.ELLIPSIS IDENTIFIER.i comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new VariableArityParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(new List()), ((String)i.value))); 
			for(Object o : l) list.add((VariableArityParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t dims.d1 ELLIPSIS.ELLIPSIS IDENTIFIER.i comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new VariableArityParameterDeclaration(new Modifiers(new List()), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(d1), ((String)i.value))); 
			for(Object o : l) list.add((VariableArityParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}

  | LPAREN.LPAREN modifiers.m name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t dims.d1 ELLIPSIS.ELLIPSIS IDENTIFIER.i comma_formal_parameter_list.l RPAREN.RPAREN RARROW.RARROW lambda_body.b {: List list = new List().add(new VariableArityParameterDeclaration(new Modifiers(m), new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(d1), ((String)i.value))); 
			for(Object o : l) list.add((VariableArityParameterDeclaration)o);
		return new LambdaExpr(new DeclaredLambdaParameters(list), b); :}
  ;
inferred_list =
    IDENTIFIER.i {: return new List().add(new InferredParameterDeclaration(((String)i.value))); :}

  | inferred_list.l COMMA.COMMA IDENTIFIER.i {: return l.add(new InferredParameterDeclaration(((String)i.value))); :}
  ;
comma_formal_parameter_list =
    COMMA.COMMA formal_parameter_list_no_vararg_mixed_array.l   ;
formal_parameter_list_no_vararg_mixed_array =
    formal_parameter_no_vararg_mixed_array.f {: return new List().add(f); :}

  | formal_parameter_list_no_vararg_mixed_array.l COMMA.COMMA formal_parameter_no_vararg_mixed_array.f {: return l.add(f); :}
  ;
formal_parameter_no_vararg_mixed_array =
    type.t IDENTIFIER.i dims_opt.d {: return new ParameterDeclaration(new Modifiers(new List()), t.addArrayDims(d), ((String)i.value)); :}

  | modifiers.m type.t IDENTIFIER.i dims_opt.d {: return new ParameterDeclaration(new Modifiers(m), t.addArrayDims(d), ((String)i.value)); :}

  | type.t ELLIPSIS.ELLIPSIS IDENTIFIER.i {: return new VariableArityParameterDeclaration(new Modifiers(new List()), t, ((String)i.value)); :}

  | modifiers.m type.t ELLIPSIS.ELLIPSIS IDENTIFIER.i {: return new VariableArityParameterDeclaration(new Modifiers(m), t, ((String)i.value)); :}
  ;
lambda_body =
    block.b {: return new BlockLambdaBody(b); :}

  | expression.e {: return new ExprLambdaBody(e); :}
  ;
abstract_method_declaration =
    interface_method_declaration.interface_method_declaration   ;
interface_method_declaration =
    interface_method_header.m method_body.b {: m.setBlockOpt(b); return m; :}
  ;
interface_method_header =
    type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN {: return new MethodDecl(new Modifiers(new List()), t.addArrayDims(new List()), IDENTIFIER, l, new List(), new Opt()); :}

  | modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN {: return new MethodDecl(new Modifiers(m), t.addArrayDims(new List()), IDENTIFIER, l, new List(), new Opt()); :}

  | type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d {: return new MethodDecl(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER, l, new List(), new Opt()); :}

  | modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d {: return new MethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, l, new List(), new Opt()); :}

  | type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws.tl {: return new MethodDecl(new Modifiers(new List()), t.addArrayDims(new List()), IDENTIFIER, l, tl, new Opt()); :}

  | modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws.tl {: return new MethodDecl(new Modifiers(m), t.addArrayDims(new List()), IDENTIFIER, l, tl, new Opt()); :}

  | type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d throws.tl {: return new MethodDecl(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER, l, tl, new Opt()); :}

  | modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d throws.tl {: return new MethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, l, tl, new Opt()); :}

  | VOID.VOID IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws_opt.tl {: return new MethodDecl(new Modifiers(new List()), new PrimitiveTypeAccess("void"), IDENTIFIER, l, tl, new Opt()); :}

  | modifiers.m VOID.VOID IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws_opt.tl {: return new MethodDecl(new Modifiers(m), new PrimitiveTypeAccess("void"), IDENTIFIER, l, tl, new Opt()); :}

  | type_parameters.p type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN {: return new GenericMethodDecl(new Modifiers(new List()), t.addArrayDims(new List()), IDENTIFIER, l, new List(), new Opt(), p); :}

  | modifiers.m type_parameters.p type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN {: return new GenericMethodDecl(new Modifiers(m), t.addArrayDims(new List()), IDENTIFIER, l, new List(), new Opt(), p); :}

  | type_parameters.p type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d {: return new GenericMethodDecl(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER, l, new List(), new Opt(), p); :}

  | modifiers.m type_parameters.p type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d {: return new GenericMethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, l, new List(), new Opt(), p); :}

  | type_parameters.p type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws.tl {: return new GenericMethodDecl(new Modifiers(new List()), t.addArrayDims(new List()), IDENTIFIER, l, tl, new Opt(), p); :}

  | modifiers.m type_parameters.p type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws.tl {: return new GenericMethodDecl(new Modifiers(m), t.addArrayDims(new List()), IDENTIFIER, l, tl, new Opt(), p); :}

  | type_parameters.p type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d throws.tl {: return new GenericMethodDecl(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER, l, tl, new Opt(), p); :}

  | modifiers.m type_parameters.p type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d throws.tl {: return new GenericMethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, l, tl, new Opt(), p); :}

  | type_parameters.p VOID.VOID IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws_opt.tl {: return new GenericMethodDecl(new Modifiers(new List()), new PrimitiveTypeAccess("void"), IDENTIFIER, l, tl, new Opt(), p); :}

  | modifiers.m type_parameters.p VOID.VOID IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws_opt.tl {: return new GenericMethodDecl(new Modifiers(m), new PrimitiveTypeAccess("void"), IDENTIFIER, l, tl, new Opt(), p); :}
  ;
modifier =
    DEFAULT.DEFAULT {: return new Modifier("default"); :}
  ;
formal_parameter_list_opt =
	 {: return new List(); :}
  | formal_parameter_list.n
	 {: return n; :}
  ;
for_update_opt =
	 {: return new List(); :}
  | for_update.n
	 {: return n; :}
  ;
block_statements_opt =
	 {: return new List(); :}
  | block_statements.n
	 {: return n; :}
  ;
expression_opt =
	 {: return new Opt(); :}
  | expression.n
	 {: return new Opt(n); :}
  ;
dims_opt =
	 {: return new List(); :}
  | dims.n
	 {: return n; :}
  ;
type_arguments_opt =
	 {: return new List(); :}
  | type_arguments.n
	 {: return n; :}
  ;
subclass_body_opt =
	 {: return new Opt(); :}
  | subclass_body.n
	 {: return n; :}
  ;
for_init_opt =
	 {: return new List(); :}
  | for_init.n
	 {: return n; :}
  ;
default_value_opt =
	 {: return new Opt(); :}
  | default_value.n
	 {: return new Opt(n); :}
  ;
argument_list_opt =
	 {: return new List(); :}
  | argument_list.n
	 {: return n; :}
  ;
element_value_pairs_opt =
	 {: return new List(); :}
  | element_value_pairs.n
	 {: return n; :}
  ;
throws_opt =
	 {: return new List(); :}
  | throws.n
	 {: return n; :}
  ;
annotation_type_element_declarations_opt =
	 {: return new List(); :}
  | annotation_type_element_declarations.n
	 {: return n; :}
  ;
